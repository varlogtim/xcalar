#!/bin/bash
#
# Easily run local Xcalar Clusters
#
# Quick start:
# ./docker-cluster load
#
#
DIR="$XLRDIR/pkg/docker"

NODES=${NODES:-1}
SHARE=${SHARE:-xcalar_root}
IMAGE=${IMAGE:-xcalar:latest}
CLUSTER=${CLUSTER:-xcalar}
HOSTPORT=443
FORCE=
ARGS=( --memory-swappiness=10
       --security-opt seccomp:unconfined
       --ulimit core=-1:-1
       --ulimit nofile=64960
       --ulimit nproc=50960:50960
       --ulimit memlock=-1:-1
       --ulimit stack=-1:-1
       -v /var/run/docker.sock:/var/run/docker.sock)
CONFDIR=$HOME/.config/docker-cluster
LATEST="/netstore/builds/Release/xcalar-latest-docker.tar.bz2"

say() {
    echo >&2 "$1"
}

die() {
    say "ERROR: $1"
    exit 1
}

usage() {
    local DC=$(basename $0)
    cat <<EOF
docker-cluster is a tool to local XCE clusters running inside of docker

Usage: $DC [command] [command arguments ...]

Command is one of:
    run, stop, rm, ssh, cssh, load

run
    [-f|--force-remove]
    [-n|--nodes COUNT ($NODES)]
    [-s|--share SHARE ($SHARE)]
    [-i|--image-id IMAGE ($IMAGE)]
    [-t|--network NETWORK (${CLUSTER}net)]
    [-c|--cluster CLUSTER ($CLUSTER)]
    [-p|--port HOSTPORT ($HOSTPORT)]

    Run a local cluster of COUNT containers based on IMAGE. The containers are
in their own network, names CLUSTER-0, CLUSTER-1 ...

rm
    [--cluster CLUSTER ($CLUSTER)]
    [-f|--force]

    Remove all containers of CLUSTER ($CLUSTER)

stop
    [--cluster CLUSTER ($CLUSTER)]
    [-f|--force]

build
    [-i|--installer INSTALLER]
    [-u|--installer-url INSTALLER_URL]

Build a new image with the provided xcalar installer.

ssh NAME

    SSH into the container named NAME. For the default CLUSTER ($CLUSTER), this would be
${CLUSTER}-0, ${CLUSTER}-1, etc..

cssh COMMAND
    [--cluster CLUSTER ($CLUSTER)]

    Run COMMAND across the entire cluster

load FILE

    Load image from FILE (usually a .tar.gz or tar.bz2).

Example run:

    docker-cluster load $LATEST
    docker-cluster run -n 5
    docker-cluster ssh xcalar-0
    docker-cluster rm -f
EOF
    exit 2
}

docker_container_ip() {
    docker inspect -f '{{range .NetworkSettings.Networks}}{{.IPAddress}}{{end}}' $1 2>/dev/null
}

parse_args() {
    while [ $# -gt 0 ]; do
        local cmd="$1"
        shift
        case "$cmd" in
            -h|--help) usage;;
            -n|--nodes) NODES=$1; shift;;
            -s|--share) SHARE=$1; shift;;
            -t|--network) NETWORK=$1; shift;;
            -i|--image-id) IMAGE="$1"; shift;;
            -c|--cluster) CLUSTER="$1"; shift;;
            -f|--force) FORCE="-f";;
            -v|--volume) VOLUMES="$VOLUMES -v $1:$1"; shift;;
            -u|--installer-url) INSTALLER_URL="$1"; shift;;
            --installer) INSTALLER="$1"; shift;;
            --) break;;
            -*) die "Unknown argument: $cmd";;
            *) set -- "$cmd" "$@"; break;;
        esac
    done
    NETWORK="${NETWORK:-${CLUSTER}net}"
}

cmd_stop() {
    parse_args "$@"

    docker ps -a | grep ${CLUSTER}- | awk '{print $1}' | xargs -r docker stop
}

cmd_rm() {
    parse_args "$@"
    local names
    names=($(docker ps -a | grep ${CLUSTER}- | awk '{print $(NF)}'))
    if [ "${#names[@]}" -gt 0 ]; then
        say "Removing ${names[*]}"
        docker rm ${FORCE} "${names[@]}" >/dev/null
        : > $CONFDIR/config
        : > $CONFDIR/names
        : > $CONFDIR/ip_address
        echo "0" > $CONFDIR/nodes
    fi
}

cmd_run() {
    parse_args "$@"

    if [ "$(docker_container_ip ${CLUSTER}-0)" != "" ]; then
        die "A cluster named $CLUSTER is already running. Use $DC rm --cluster $CLUSTER first"
    fi

    local count name node_id port
    if [ -n "$NETWORK" ]; then
        docker network inspect "$NETWORK" >/dev/null 2>&1 \
            || docker network create -d bridge $NETWORK
    fi
    local config=${CONFDIR}/${CLUSTER}.cfg
    cat > $config <<-EOF
	Constants.XcalarRootCompletePath=/var/opt/xcalar
	Constants.BufferCacheLazyMemLocking=true
	Thrift.Port=9090
	Thrift.Host=localhost
	// --- Start of auto-generated stuff ---
	// Cluster management stuff. The following has been
	// auto-generated by genConfig.sh
	Node.NumNodes=${NODES}
	EOF
    for node_id in $(seq 0 $((NODES-1))); do
        echo Node.${node_id}.IpAddr=${CLUSTER}-${node_id} >> $config
        echo Node.${node_id}.Port=5000 >> $config
        echo Node.${node_id}.ApiPort=18552 >> $config
        echo Node.${node_id}.MonitorPort=8000 >> $config
    done

    local tmpFsPctOfPhysicalMem=70
    local tmpFsSizeKb=$(cat /proc/meminfo | grep MemTotal | awk '{ printf "%.0f\n", $2*'$tmpFsPctOfPhysicalMem'/100}')

    local cids=() cid name node_id port
    echo $CLUSTER > $CONFDIR/cluster
    echo $NODES > $CONFDIR/nodes
    for node_id in $(seq 0 $((NODES-1))); do
        if [ $node_id -eq 0 ]; then
            if nc -w 0 0.0.0.0 $HOSTPORT; then
                say "WARNING: Desired port on host ($HOSTPORT) is already taken"
                port="-p 443"
            else
                port="-p ${HOSTPORT}:443"
            fi
        else
            port=
        fi
        name=${CLUSTER}-${node_id}
        cid=$(docker create "${ARGS[@]}" $port \
            -v ${SHARE}:/var/opt/xcalar $VOLUMES \
            --cap-add=ALL \
            --ulimit nofile=64960:120000 \
            --shm-size=${tmpFsSizeKb%.*}k ${NETWORK:+--network $NETWORK} \
            --name $name \
            --hostname $name \
            -e CLUSTER=$CLUSTER \
            -e XCE_NODEID=$node_id \
            -e XCE_NUMNODES=$NODES \
            $IMAGE)
        say "Creating $name ..."

        docker cp $config $cid:/etc/xcalar/default.cfg
        docker cp $DIR/supervisor.conf $cid:/etc/xcalar/supervisor.conf
        cids+=($cid)
    done
    printf "Starting containers ..." >&2
    for cid in "${cids[@]}"; do
        docker start $cid >/dev/null
    done
    say "Done!"
    local site
    site="$(docker port ${CLUSTER}-0 443 | sed 's@0.0.0.0@https://'$(hostname -f)'@g')"
    echo "XD: $site"
    : > $CONFDIR/config
    : > $CONFDIR/names
    : > $CONFDIR/ip_address
    for node_id in $(seq 0 $((NODES-1))); do
        local name=${CLUSTER}-${node_id}
        local ip_address="$(docker_container_ip "$name")"
        echo $name >> $CONFDIR/names
        echo $ip_address >> $CONFDIR/ip_address
        printf "Host $name node${node_id} $node_id\n\tHostname $ip_address\n\n" >> $CONFDIR/config
    done
    cat >> $CONFDIR/config<<EOF

Host *
    StrictHostKeyChecking   no
    UserKnownHostsFile      /dev/null
    User                    xctest
    IdentityFile            ~/.ssh/id_xctest
    IdentitiesOnly          yes
EOF
}

cmd_load() {
    local file
    for file in "$@"; do
        say "Loading $file ..."
        if [[ "$file" =~ .tar.bz2$ ]]; then
            pbzip2 -dc "$file" | docker load
        elif [[ "$file" =~ .tar.gz$ ]]; then
            pigz -dc "$file" | docker load
        elif [[ "$file" =~ .tar$ ]]; then
            docker load < "$file"
        else
            die "Don't know how to load $file. Use docker load."
        fi
        if [ $? -ne 0 ]; then
            die "Failed to load $file"
        fi
    done
}

cmd_cssh() {
    unset SSH_AUTH_SOCK
    parse_args "$@"
    local ip_address node
    for node in $(docker ps | grep "${CLUSTER}"- | awk '{print $(NF)}'); do
        if ip_address="$(docker_container_ip $node)"; then
            ssh -oStrictHostKeyChecking=no -oUserKnownHostsFile=/dev/null -i ~/.ssh/id_xctest -l xctest $ip_address "$@"
        fi
    done
}

cmd_ssh() {
    unset SSH_AUTH_SOCK
    parse_args "$@"
    local ip_address node
    if [ -z "$1" ]; then
        ip_address=$(docker_container_ip "${CLUSTER}-0")
    else
        ip_address=$(docker_container_ip "$1")
        [ -n "$ip_address" ] || ip_address=$(docker_container_ip "${CLUSTER}-${1}")
        shift
    fi
    [ -n "$ip_address" ] || die "Failed to find the ip address"
    ssh -oStrictHostKeyChecking=no -oUserKnownHostsFile=/dev/null -i ~/.ssh/id_xctest -l xctest $ip_address "$@"
}

cmd_build() {
    local port=8888
    parse_args "$@"
    if [ -z "$INSTALLER" ] && [ -z "$INSTALLER_URL" ]; then
        die "Must specify either --installer or --installer-url"
    fi
    local httpd_pid rc
    if [ -n "$INSTALLER" ]; then
        if ! test -r "$INSTALLER"; then
            die "$INSTALLER couldn't be read"
        fi
        INSTALLER=$(readlink -f $INSTALLER)
        local installer_dir="$(dirname $INSTALLER)"
        cd "$installer_dir" || die "Failed to cd to $installer_dir"
        pkill -f "caddy -port $port"
        caddy -port $port -root "$(dirname $INSTALLER)" 'tls self_signed' browse & </dev/null
        httpd_pid=$!
        INSTALLER_URL="https://$(hostname -i):${port}/$(basename $INSTALLER)"
        sleep 2
        if ! nc -w 0 "$(hostname -i)" $port; then
            kill -TERM $httpd_pid 2>/dev/null
            wait $httpd_pid
            die "Failed to serve your installer at $INSTALLER_URL"
        fi
    fi
    if curl -k -sSfL -v -X GET -r 1-8 "$INSTALLER_URL"; then
        (cd $DIR && make INSTALLER_URL=$INSTALLER_URL)
        rc=$?
        if [ -n "$httpd_pid" ]; then
            kill -TERM $httpd_pid 2>/dev/null
            kill -9 $httpd_pid 2>/dev/null
            wait $httpd_pid 2>/dev/null
        fi
    fi
    return $rc
}

init() {
    if ! test -d $CONFDIR; then
        mkdir -p $CONFDIR
        cd $CONFDIR
        echo 0 > nodes
        echo $CLUSTER > cluster
        : > names
        : > ip_addresses
        : > config
        cd - >/dev/null
    fi

    # Generate ssh config file
    if ! test -e ~/.ssh/id_xctest; then
        mkdir -m 0700 -p ~/.ssh
        curl -f -s http://netstore/infra/keys/id_xctest -o ~/.ssh/id_xctest || die "Failed to fetch key"
        chmod 0400 ~/.ssh/id_xctest
    fi
}

main() {
    init
    test $# -gt 0 || set -- help
    CMD=run
    case "$1" in
        -*) CMD=run;;
        build|load|run|stop|rm|cssh|ssh) CMD="$1"; shift;;
        help) usage;;
        *) echo >&2 "ERROR: Unknown subcommand \"$1\""; usage;;
    esac
    eval cmd_${CMD} "$@"
}

main "$@"
#__SCRIPT__ENDS__
exit
__PAYLOAD__STARTS__


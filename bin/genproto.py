#!/usr/bin/env python3.6

# Copyright 2017 Xcalar, Inc. All rights reserved.
#
# No use, or distribution, of this source code is permitted in any form or
# means without a valid, written license agreement with Xcalar, Inc.
# Please refer to the included "COPYING" file for terms and conditions
# regarding the use and redistribution of this software.
import math
import sys
import os
import argparse
import logging
import re
import types
import difflib
import uuid
import subprocess as sp

import pygccxml
from pygccxml import utils
from pygccxml import declarations
from pygccxml import parser

argParser = argparse.ArgumentParser()

argParser.add_argument('-b', dest='blist', required=False,
                    default='', type=str,
                    help='Comman separated structs to ignore')
argParser.add_argument('-c', dest='cout', required=True, type=str,
                    help='C code output path/prefix')
argParser.add_argument('-C', dest='cmakedir', required=False, type=str,
                    help='Cmake build dir (if using cmake)')
argParser.add_argument('-f', dest='fin', required=True,
                    help='File containing parent struct')
argParser.add_argument('-i', dest='inIdl', required=False, type=str,
                    help='IDL input path/prefix')
argParser.add_argument('-l', dest='listvarchar', required=False, action='store_true',
                    help='List all variable size character arrays')
argParser.add_argument('-n', dest='ns', required=True,
                    help='Bottom-level protobuf namespace (e.g. dag)')
argParser.add_argument('-p', dest='proto', required=True, type=str,
                    help='IDL output path/prefix')
argParser.add_argument('-P', dest='public', required=False, type=str,
                    help='List of structs for which to generate public SerDes interfaces')
argParser.add_argument('-s', dest='durable', required=True,
                    help='Name of struct to make durable')
argParser.add_argument('-u', dest='uniquify', required=False, action='store_true',
                    help='Add a random header to produce a unqiue IDL (use with -F)')
argParser.add_argument('-U', dest='unused', required=False, action='store_true',
                    help='Print unused protobuf fields')
argParser.add_argument('-v', dest='varlen', required=False, action='store_true',
                    help='Print nested variable length fields')
argParser.add_argument('-x', dest='xcalar', required=True, type=str,
                    help='Path to Xcalar source')
args = argParser.parse_args()

wiki = 'http://wiki.int.xcalar.com/mediawiki/index.php/Durables'

# XXX: Should pass these in as cmdline args from build system
incDirListBase = [
    "src/include",
    "src/include",
    "src/include/primitives",
    "src/include/libapis",
    "src/include/test",
    "src/include/test/FuncTests",
    "src/lib/libprotobuf",
    "src/3rd/getOpt",
    "src/3rd/bsd",
    "src/3rd/lmdb",
    "src/3rd/decNumber",
]

incDirList = []
if args.cmakedir:
    incDirList += [args.cmakedir + '/' + x for x in incDirListBase]

incDirList += [args.xcalar + '/' + x for x in incDirListBase]
incDirList += [".", "/opt/xcalar/include/python3.6m", "/usr/include"]

pygccxml.utils.utils.loggers.set_level(logging.ERROR)

copyrightEtc ='''// Copyright 2017 Xcalar, Inc. All rights reserved.
//
// No use, or distribution, of this source code is permitted in any form or
// means without a valid, written license agreement with Xcalar, Inc.
// Please refer to the included "COPYING" file for terms and conditions
// regarding the use and redistribution of this software.

// Updating durable data structures must be done with care.  Please carefully
// read %s for instructions.

''' % (wiki,)

autogenMsg =  '// This file AUTOGENERATED\n'
autogenMsg += '// DO NOT EDIT THIS FILE BY HAND\n\n'
autogenMsg += '// ===> %s for details\n' % (wiki,)

minorVersMsg  = '// This file semi-autogenerated by %s\n' % (os.path.basename(__file__),)
minorVersMsg += '// Any custom minor versioning code can be added by hand here\n'
minorVersMsg += '// This file is designed for three-way merging with the\n'
minorVersMsg += '// autogenerated version.  Please try to minimize the opportunity\n'
minorVersMsg += '// for merge conflicts.\n\n'
minorVersMsg += '// ===> %s for details\n' % (wiki,)

protoHdr = copyrightEtc + autogenMsg + '''
syntax = "proto3";

import "google/protobuf/timestamp.proto";
import "google/protobuf/wrappers.proto";

option cc_enable_arenas = true;

package xcalar.internal.durable.%s;

''' % (args.ns,)

cInc = '''
#include <exception>
#include "StrlFunc.h"
#include "sys/XLog.h"

'''

xcalarApiDepth = 3
# Maximum depth with which to resolve pointers.
maxPtrResolutionDepth = xcalarApiDepth

# Support some basic code indentation.  Can always post-process with astyle or similar
spacesPerIndent = 4
def genStr(indentLevel, currStr):
    indentStr = ' ' * spacesPerIndent * indentLevel
    return indentStr + currStr

def blkInd(indentLevel, currStr):
    indentStr = ' ' * spacesPerIndent * indentLevel
    return '\n'.join([indentStr + x for x in currStr.split('\n')])

# Takes a dictionary and returns a list of the values sorted by key
def sortDict(d):
    return [d[k] for k in sorted(d)]

# Return a string of values of a dictionary sorted by key
def sortDictToStr(d):
    return '\n'.join(sortDict(d))

class TodoItem(object):
    def __init__(self, decl, name, depth, parentList=[]):
        self.decl = decl
        self.depth = depth
        self.name = name
        self.parentList = parentList

class IDLCompatError(Exception):
    pass

class GenProto:
    def __init__(self):
        pbNsBase = 'xcalar::internal::durable::'
        self.pbNs = pbNsBase + args.ns + '::'

        self.generator_path, self.generator_name = utils.find_xml_generator()
        self.config = parser.xml_generator_configuration_t(
            xml_generator_path=self.generator_path,
            xml_generator=self.generator_name,
            cflags='--std=c++11',
            compiler="g++",
            include_paths=incDirList)
        self.decls = parser.parse([args.fin], self.config)
        self.global_ns = declarations.get_global_namespace(self.decls)

        self.blist = args.blist.split(',') + ['Scalar *', 'XcalarApiInput *']
        self.public = args.public.split(',')

        # Map common fundamental c types to protobuf wrappers
        self.ctypeToPbMap = {
                             'bool': 'google.protobuf.BoolValue',
                             'char': 'google.protobuf.Int32Value',
                             'unsigned char': 'google.protobuf.UInt32Value',
                             'unsigned int': 'google.protobuf.UInt64Value',
                             'long unsigned int': 'google.protobuf.UInt64Value', # uint64_t typedef
                             'int': 'google.protobuf.Int64Value',
                             'long int': 'google.protobuf.Int64Value', # int64_t typedef
                             'long signed int': 'google.protobuf.Int64Value',
                             'long long': 'google.protobuf.Int64Value',
                             'double': 'google.protobuf.DoubleValue', # float64_t typedef
                             'float': 'google.protobuf.FloatValue',
                             }

        # Make aggregated types in protobuf by prefixing the fundamental C
        # types with the protobuf "repeated" qualifier
        self.carrayToPbMap = {k: 'repeated ' + v for k, v in self.ctypeToPbMap.items()}
        # Character strings are special
        # XXX: Use BytesValue instead of StringValue to work around bug 7730
        self.carrayToPbMap['char'] = 'google.protobuf.BytesValue'
        self.carrayToPbMap['varchar'] = 'google.protobuf.StringValue'
        self.carrayToPbMap['ptr'] = 'google.protobuf.BytesValue'

        # How to get the field which tells us how to demux the union
        # If the field is named <unionFieldName>Elm (ie the union field name
        # with the string "Elm" appended), this is automatic and no entry is
        # needed here.  Note the key is the class -containing- the union of
        # interest.
        # XXX: Structs with multiple unions are not supported for now, but
        # support is easily added by using a list value here...
        self.unionElmSelectorMap = {
                'XcalarApiParamInput': 'raw->paramType',
                'ExExportTarget': 'raw->hdr.type',
                'ExExportMeta': 'raw->target.type',
                'ExInitExportUDFInput': 'raw->format',
                'ExInitExportSFInput': 'raw->format',
                'SerializedDagNode': 'raw->dagNodeHdr.apiDagNodeHdr.api',
                }

        # How to get the number of items in non-null terminated arrays and
        # variable size structs.
        # If the struct author uses the standard naming scheme of
        # <arrayName>Count for the variable that contains the number of array
        # elements this is all automatic and no entry is needed here.
        # Note that for 2D arrays this is used to bound the first (potentially
        # variable) dimension
        self.varSizeCountMap = {
                'Packed': {'reserved': '(ssize_t)(sizeof(raw->reserved)/sizeof(*raw->reserved))',
                           'exec': 'raw->execSize'},
                # XXX check array_size
                'XcalarApiGetRowNumInput': {'rowCountPerNode': 'MaxNodes'},
                'XdbLoadArgs': {'fieldNames': 'TupleMaxNumValuesPerRecord'},
                'ParseArgs': {'oldNames': 'raw->fieldNamesCount',
                              'types': 'raw->fieldNamesCount'},
                'XcalarApiIndexInput': {'keys': 'raw->numKeys'},
                'XcalarApiUpdateInput': {'updates': 'raw->numUpdates'},
                'XcalarApiSelectInput': {'columns': 'raw->numColumns'},
                'Uuid': {'buf': '(ssize_t)(sizeof(raw->buf)/sizeof(*raw->buf))'},
                'XcalarApiKeyAppendInput': {'suffix': 'raw->suffixSize'},
                'XcalarApiKeySetIfEqualInput': {'values': 'raw->valueCompareSize + raw->valueReplaceSize + raw->valueSecondarySize'},
                'UdfModuleSrc': {'source': 'raw->sourceSize'},
                'XcalarApiPreviewInput': {'inputJson': 'raw->inputLen'},
                'XcalarApiKeyValuePair': {'value': 'raw->valueSize'},
                'XcalarApiAppRunInput': {'inStr': 'raw->inStrSize'},
                'SerializedDagNode': {'parentsList': 'raw->numParent'},
                'SerializedDagNodesContainer': {'dagNodes': 'raw->containerHdr.numNodes'},
                'XcalarApiJoinInput': {'renameMap': 'raw->numLeftColumns + raw->numRightColumns'},
                'TupleValueDesc': {'valueType': '(ssize_t)raw->numValuesPerTuple'},
                'XcalarApiExecuteRetinaInput': {'parameters' : 'raw->numParameters'},
                'XcalarApiStartFuncTestInput': {'testNamePatterns': 'raw->numTestPatterns'},
                'XcalarApiProjectInput': {'columnNames': 'raw->numColumns'},
                'XcalarApiStatByGroupIdInput': {'groupId': 'raw->numGroupId'},
                'RetinaDst': {'columns': 'raw->numColumns'},
                'ExExportMeta': {'columns': 'raw->numColumns'},
                'XcalarStressSetKeyTypeInput': {'xdbIds': 'raw->numXdbIds'},
                'XcalarApiUnionInput': {'renameMapSizes': '(ssize_t)raw->numSrcTables',
                                        'renameMap': '(ssize_t)raw->numSrcTables',
                                        'srcTables': '(ssize_t)raw->numSrcTables'},
                'XcalarApiMakeRetinaInput': {'srcTables': '(ssize_t)raw->numSrcTables',
                                             'columnHints': '(ssize_t)raw->numColumnHints'},
                'XcalarApiGroupByInput': {'evalStrs': '(ssize_t)raw->numEvals',
                                          'newFieldNames': '(ssize_t)raw->numEvals',
                                          'keys': 'raw->numKeys'},
                'XcalarApiMapInput': {'evalStrs': '(ssize_t)raw->numEvals',
                                             'newFieldNames': '(ssize_t)raw->numEvals'},
                }

        # Map union fields to enum definitions.  Key is the union name and value
        # is either a function that generates the mapping or a lookup dictionary.
        # For now there is no default naming here to avoid compile time confusion.
        self.unionEnumMap = {
                'XcalarApiInput': lambda x, y: re.sub(r'Input.*$', r'', x),
                'ExAddTargetSpecificInput': lambda x, y: re.sub(r'ExAddTarget(.*)Input', r'ExTarget\1Type', x),
                'ExInitExportSpecificInput': lambda x, y: re.sub(r'ExInitExport(.*)Input', r'ExTarget\1Type', x),
                'ExInitExportFormatSpecificArgs': lambda x, y: re.sub(r'ExInitExport(\w)(.*)Args', lambda m: 'DfFormat'+m.group(1)+m.group(2).lower(), x),
                'XcalarApiParamInputArgs': lambda x, y: re.sub(r'(\w+)Param(\w*)', r'\1\2', x),

                }

        # Any pointers we wish to dereference must be included here with the mapping
        # to the data size
        self.ptrSerializeMap = {
                'XcalarApiExecuteRetinaInput': {'exportRetinaBuf': 'raw->exportRetinaBufSize'},
                }

        # Structs can share field types, so keep track of what we've done (ie
        # declaration objects we've visited) so we only generate a single
        # message regardless of the number of times the type is used.
        self.processedList = []

        # List of compound types (declaration objects) that must be recursively
        # resolved into protobuf messages
        self.todoList = []

    def parseEnum(self, currEnums, oldEnum):
        self.processedList.append(currEnums)
        enumStrList = []
        for currEnum in currEnums.values:
            enumStr = '    '
            enumStr += currEnum[0] + ' = ' + str(currEnum[1]) + ';'
            enumStrList.append(enumStr)

        if oldEnum:
            assert(oldEnum['isEnum'])
            if len(oldEnum['body']) > 0:
                # A common pattern is to terminate an enum with an "...Invalid"
                # or "...Max" element.  Maintaining this pattern requires an
                # exception to append only enums
                if re.match(r'.*Invalid =|.*Max =', oldEnum['body'][-1]):
                    oldEnum['body'].pop()

            oldMsgSet = frozenset(oldEnum['body'])
            currMsgSet = frozenset(enumStrList)
            if not oldMsgSet.issubset(currMsgSet):
                self.printCompatError()
                self.printErr('Original IDL enum field(s) improperly modified:')
                for field in list(oldMsgSet - currMsgSet):
                    self.printErr(field)
                # raise IDLCompatError(currEnums.name + ': Invalid IDL enum change')

            newElms = currMsgSet - oldMsgSet
            enumBodyList = oldEnum['body'] + sorted(newElms, key=enumStrList.index)
        else:
            enumBodyList = enumStrList

        headerStr = 'enum ' + currEnums.name + ' {\n'
        outStr = headerStr + '\n'.join(enumBodyList)
        outStr += '\n}\n'

        return outStr

    # Add compound types to a list for subsequent processing into a protobuf
    # message
    def addTodo(self, decl, name, depth, parentList=[]):
        if decl not in (self.processedList + self.todoList):
            self.todoList.append(TodoItem(decl, name, depth + 1, parentList + [name]))

    def printErr(self, errStr):
        sys.stderr.write(errStr + '\n')

    def is2DArray(self, decl):
        dims = 0
        for currType in declarations.decompose_type(decl):
            if type(currType) == pygccxml.declarations.cpptypes.array_t:
                dims += 1

        return dims == 2

    def numPtrs(self, decl):
        dims = 0
        for currType in declarations.decompose_type(decl):
            if type(currType) == pygccxml.declarations.cpptypes.pointer_t:
                dims += 1

        return dims

    def isPtr(self, decl):
        return self.numPtrs(decl) == 1

    def isPtrPtr(self, decl):
        return self.numPtrs(decl) == 2

    # Return the size of a particular zero-based dimension of an array
    def getArrayDimSize(self, decl, dimension):
        currDim = 0
        for currType in declarations.decompose_type(decl):
            if type(currType) == pygccxml.declarations.cpptypes.array_t:
                if currDim == dimension:
                    return declarations.array_size(currType)
                currDim += 1
        raise IndexError

    def isAnon(self, var):
        return not var.name

    def numberMessage(self, msgBody):
        rhs = [' = ' + str(x) + ';' for x in range(1, len(msgBody)+1)]
        return [a + b for a, b in zip(msgBody, rhs)]

    def printCompatError(self):
        self.printErr('ERROR ' * 8)
        w = 'ERROR: '
        self.printErr(w + 'Invalid IDL change.  This can be caused by:')
        self.printErr(w + '* Deleting fields of durable structs/enums')
        self.printErr(w + '* Renaming fields of durable structs/enums')
        self.printErr(w + '* Changing the type of fields of durable structs/enums')
        self.printErr(w + '* Changing the value of enum fields')
        self.printErr(w + '* Changing the union status of aggregates')
        self.printErr(w + 'See ' + wiki)
        self.printErr(w + 'for more detials.')
        self.printErr(w + 'DO NOT ATTEMPT TO DEFEAT THIS CHECK! Doing so will break')
        self.printErr(w + 'backward compatibility with previous versions of durable data.')

    def parseStruct(self, currClass, parentDepth, oldMsg):
        if type(currClass) != declarations.class_declaration.class_t:
            return ''

        if currClass.name in self.blist:
            return ''

        self.processedList.append(currClass)
        header = ['message ' + currClass.name + ' {']
        indents = 4

        isOneof = currClass.class_type == declarations.class_declaration.CLASS_TYPES.UNION
        ind = 1
        if isOneof:
            outStr = ''
            outStr += genStr(ind, 'oneof ' + currClass.name + ' {')
            header += [outStr]
            ind += 1

        headerStr = '\n'.join(header) + '\n'
        outStrList = []
        membersList = currClass.get_members()
        while membersList:
            memb = membersList.pop(0)
            outStr = ''
            try:
                if type(memb) == declarations.variable.variable_t:
                    if str(memb.decl_type) in self.blist:
                        continue

                    if self.isAnon(memb):
                        # Anonymous nested union/struct.  Flatten it.
                        # XXX: Unions will be deunionized here; should handle
                        # this better
                        membersList += memb.decl_type.declaration.get_members()
                        continue

                    # Among other things this will resolve typedefs to their
                    # base fundamental or compound type
                    baseDecl = declarations.base_type(memb.decl_type)
                    baseDeclStr = str(baseDecl)

                    # XXX: regex hack to remove class scope resolution operator
                    baseDeclStr = re.sub(r'.*::', r'', baseDeclStr)
                    if declarations.is_pointer(memb.decl_type):
                        if parentDepth > maxPtrResolutionDepth:
                            continue
                        if declarations.is_fundamental(baseDecl):
                            if type(baseDecl) == pygccxml.declarations.cpptypes.char_t:
                                pbType = self.carrayToPbMap['ptr']
                            else:
                                pbType = self.carrayToPbMap[baseDeclStr]
                        else:
                            self.addTodo(baseDecl.declaration, memb.name, parentDepth)
                            pbType = 'repeated ' + baseDeclStr
                        outStr += genStr(ind, pbType + ' ' + memb.name)
                    elif declarations.is_array(memb.decl_type):
                        if declarations.is_fundamental(baseDecl) and not self.is2DArray(memb.decl_type):
                            arrSize = self.getArrayDimSize(memb.decl_type, 0)
                            if baseDeclStr == 'char' and not arrSize:
                                # Handle variable length character array fields as null terminated strings.
                                # Per bug 7730 can only contain valid UTF-8 codes
                                pbType = self.carrayToPbMap['varchar']
                                if args.listvarchar:
                                    print('Found varchar array: ' + currClass.name + '.' + memb.name)
                            else:
                                if declarations.is_pointer(declarations.array_item_type(memb.decl_type)):
                                    if parentDepth > maxPtrResolutionDepth:
                                        continue
                                    if declarations.is_fundamental(baseDecl):
                                        pbType = 'repeated ' + self.carrayToPbMap['varchar']
                                    else:
                                        # This is an array of pointers to compound types.  Not currently supported.
                                        # Support involves emitted a repeated of the type and adding it to todoList.
                                        continue
                                else:
                                    pbType = self.carrayToPbMap[baseDeclStr]
                        else:
                            if declarations.is_fundamental(baseDecl):
                                pbType = 'repeated ' + self.carrayToPbMap[baseDeclStr]
                            else:
                                self.addTodo(baseDecl.declaration, memb.name, parentDepth)
                                pbType = 'repeated ' + baseDeclStr
                        outStr += genStr(ind, pbType + ' ' + memb.name)
                    elif type(baseDecl) == declarations.cpptypes.declarated_t:
                        assert(not declarations.is_fundamental(baseDecl))
                        # This is a compound type so no direct translation to protobuf
                        pbType = baseDeclStr

                        # If we haven't already, add the compount type to
                        # the list so we process it and generate a protobuf
                        # message for it
                        self.addTodo(baseDecl.declaration, memb.name, parentDepth)

                        outStr += genStr(ind, pbType + ' ' + memb.name)
                    else:
                        pbType = self.ctypeToPbMap[baseDeclStr]
                        outStr += genStr(ind, pbType + ' ' + memb.name)

                    outStrList.append(outStr)
            except KeyError:
                # Cause protobuf compile to break
                outSerStr = 'XXX ERROR: cannot handle %s %s\n' % (str(memb.decl_type), memb.name, )
                outStrList.append(outStr)

        if oldMsg:
            assert(not oldMsg['isEnum'])
            if oldMsg['isOneof'] != isOneof:
                self.printCompatError()
                raise IDLCompatError(currClass.name + ': Invalid Union/Struct change')
            oldMsgSet = frozenset(oldMsg['body'])
            currMsgSet = frozenset(outStrList)
            if not oldMsgSet.issubset(currMsgSet):
                for field in list(oldMsgSet - currMsgSet):
                    if args.unused:
                        unusedFieldName = field.lstrip().split(' ')[1]
                        print("Unused protobuf field %s::%s" % (currClass.name, unusedFieldName))


            newElms = currMsgSet - oldMsgSet

            # Take care to preserve ordering of existing fields
            msgBody = oldMsg['body'] + list(newElms)
        else:
            msgBody = outStrList

        msgBody = self.numberMessage(msgBody)

        outStr = '\n'.join(msgBody)
        outStr = headerStr + outStr
        outStr += '\n'
        if isOneof:
            outStr += genStr(1, '}\n')
        outStr += '}\n'

        return outStr

    # Reads a .proto file from disk and parses it into a dictionary of messages
    # wherein each message body is a list of message types and field names
    def parseProto(self, fname):
        ret = {}
        try:
            with open(fname, 'r') as fh:
                line = fh.readline()
                while line:
                    isMessage = bool(re.match(r'message.*', line))
                    isEnum = bool(re.match(r'enum.*', line))
                    if isMessage or isEnum:
                        msgName = line.split()[1]
                        line = fh.readline()
                        ret[msgName] = {}
                        ret[msgName]['body'] = []
                        ret[msgName]['isOneof'] = False
                        ret[msgName]['isEnum'] = isEnum
                        while line:
                            if re.match(r' *oneof', line):
                                ret[msgName]['isOneof'] = True
                                line = fh.readline()
                            line = line.rstrip('\n')
                            if isMessage:
                                # Get rid of protobuf message field numbers
                                line = re.sub(r'(.*) =.*', r'\1', line)
                            ret[msgName]['body'].append(line)
                            line = fh.readline()
                            if re.match(r' *}', line):
                                line = fh.readline()
                                if re.match(r' *}', line):
                                    line = fh.readline()
                                break

                    line = fh.readline()
                return ret

        except IOError as e:
            self.printErr("Error loading %s: %s" % (fname, e))
            return None

    # Returns true if there is an IDL change
    def checkIdl(self, fname, generatedIdl):
        try:
            with open(fname, 'r') as fh:
                currIdl = fh.read()
        except IOError:
            # No existing IDL
            currIdl = ''

        currIdlSplit = currIdl.split('\n')
        generatedIdlSplit = generatedIdl.split('\n')
        if currIdlSplit[1:] == generatedIdlSplit[1:]:
            print("No autogenerated IDL changes in " + fname)
            return False
        else:
            d = difflib.Differ()
            idlDiff = '\n'.join(difflib.unified_diff(currIdlSplit, generatedIdlSplit))
            self.printErr('WARNING ' * 8)
            self.printErr(idlDiff)
            w = 'WARNING: '
            self.printErr(w + 'IDL change detected in ' + fname)
            self.printErr(w + 'See diff output above for details.')
            self.printErr(w + 'See ' + wiki)
            self.printErr(w + 'for IDL change procedures that MUST be followed BEFORE check in.')
            self.printErr(w + 'Your code will NOT pass verification without strictly following')
            self.printErr(w + 'the procedures outlined in ' + wiki)

            self.printErr('New IDL and SerDes methods generated, rebuild to pick up these changes')
            self.printErr('then add the modified files to your commit')

            return True

    def getOldElm(self, oldIdl, name):
        try:
            return oldIdl[name]
        except (KeyError, TypeError):
            # TypeError in case old IDL file is non-existent (we're
            # creating it for the first time).  KeyError in case we're
            # adding an entirely new message to existing IDL
            return None

    def makeMsgFromExisting(self, msgName, existingIdl):
        body = existingIdl[msgName]['body']
        if existingIdl[msgName]['isEnum']:
            outStr = genStr(0, 'enum %s {\n' % msgName)
            msgBody = body # already numbered, no need to number again
        else:
            outStr = genStr(0, 'message %s {\n' % msgName)
            msgBody = self.numberMessage(body)
        outStr += '\n'.join(msgBody)
        outStr += genStr(0, '\n}\n')
        return outStr

    # Breadth-first traversal of structs
    def parseStructs(self, motherStruct):
        self.processedList = []

        motherDecl = self.getDeclByName(motherStruct)
        # print declarations.full_name(motherDecl)
        self.todoList = [TodoItem(motherDecl, '', 0)]

        outDict = {}

        of = args.proto + '.proto'
        # Load existing IDL for verification
        if args.inIdl:
            inIdl = args.inIdl + '.proto'
            oldIdl = self.parseProto(inIdl)
        else:
            # No input IDL specified so read in the existing IDL from the
            # output path
            inIdl = args.proto + '.proto'
            oldIdl = self.parseProto(inIdl)

        while self.todoList:
            todoItem = self.todoList.pop(0)
            currClass = todoItem.decl
            if currClass in self.processedList:
                continue

            oldMsg = self.getOldElm(oldIdl, currClass.name)
            if declarations.is_enum(currClass):
                outDict[currClass.name] = self.parseEnum(currClass, oldMsg)
            else:
                outDict[currClass.name] = self.parseStruct(currClass, todoItem.depth, oldMsg)

        # Preserve old message types for backward compatibility
        deprecatedMsgs = frozenset(list(oldIdl.keys())) - frozenset(list(outDict.keys()))
        for deprecatedMsg in deprecatedMsgs:
            outDict[deprecatedMsg] = self.makeMsgFromExisting(deprecatedMsg, oldIdl)

        outList = sortDict(outDict)
        outStr = '// Optional uniquifier (OK to ignore diffs on this line):'
        if args.uniquify:
            outStr += str(uuid.uuid4())+'\n'
        else:
            outStr += '\n'
        outStr += protoHdr
        outStr += '\n'.join(outList)

        idlChanged = self.checkIdl(of, outStr)
        if idlChanged:
            # Only write the IDL if there was a change so as not to trigger
            # unnecessary rebuilds of modules.
            with open(of, 'w') as fh:
                fh.write(outStr)

        return idlChanged

    def getArrayCount(self, typeName, varName):
        try:
            return self.varSizeCountMap[typeName][varName]
        except KeyError:
            # No custom count variable so return the standard.
            # Build will break if it doesn't exist.
            # XXX: Check for standard's existance here instead of build
            return 'raw->' + varName + 'Count'

    def parseStructToC(self, currClass, parentDepth, parentName, baseName):
        if currClass.name in self.blist:
            return ('', '', '', '', '')

        self.processedList.append(currClass)

        isUnion = currClass.class_type == declarations.class_declaration.CLASS_TYPES.UNION

        if currClass.name != currClass.top_class.name:
            rawType = currClass.top_class.name+'::'+currClass.name
        else:
            rawType = currClass.name
        outSerStrList = []
        outDesStrList = []
        outUnionSizeList = []
        numCountArgs = 0
        numUnionElms = 1
        pbSerPrefix = 'pbSer'
        pbDesPrefix = 'pbDes'
        pbUnionSizePrefix = 'pbUnionSize'
        pbVarlenSizePrefix = 'pbVarlenSize'
        membersList = currClass.get_members()
        outVarlenSizeStr = ''
        while membersList:
            memb = membersList.pop(0)
            outSerStr = ''
            outDesStr = ''
            outUnionSizeStr = ''

            try:
                if type(memb) == declarations.variable.variable_t:
                    if str(memb.decl_type) in self.blist:
                        continue

                    if self.isAnon(memb):
                        # Anonymous nested union/struct.  Flatten it.
                        # XXX: Nested anonymous unions will be deunionized here.
                        # This works for the existing nested anonymous unions
                        # because the elements are the same size.  We should fix
                        # this by assigning such unions internal names as
                        # protobuf doesn't support nested/anon unions.
                        membersList += memb.decl_type.declaration.get_members()
                        continue

                    try:
                        if type(self.unionEnumMap[currClass.name]) == types.LambdaType:
                            numUnionElmsStr = self.unionEnumMap[currClass.name](str(memb.decl_type), memb.name)
                        else:
                            numUnionElmsStr = self.unionEnumMap[currClass.name][str(memb.decl_type)]
                    except KeyError:
                        numUnionElmsStr = str(numUnionElms)

                    caseStr = genStr(2, 'case %s:\n' % (numUnionElmsStr,))

                    # Among other things this will resolve typedefs to their
                    # base fundamental or compound type
                    baseDecl = declarations.base_type(memb.decl_type)
                    baseDeclStrOrig = str(baseDecl)

                    # XXX: regex hack to remove class scope resolution operator
                    baseDeclStr = re.sub(r'.*::', r'', baseDeclStrOrig)

                    if declarations.is_pointer(memb.decl_type):
                        if parentDepth > maxPtrResolutionDepth:
                            continue
                        try:
                            # For now only deref and serialize pointers explicitly requested
                            bytesField = self.ptrSerializeMap[currClass.name][memb.name]
                            outSerStr += genStr(1, 'pb->mutable_%s()->set_value(raw->%s, %s);' % (memb.name.lower(), memb.name, bytesField,))
                            outDesStr += genStr(1, 'memcpy(raw->%s, pb->%s().value().c_str(), %s);' % (memb.name, memb.name.lower(), bytesField,))
                        except KeyError:
                            if type(baseDecl) == declarations.cpptypes.declarated_t:
                                self.addTodo(baseDecl.declaration, memb.name, parentDepth)
                                pbType = baseDeclStr
                                rawPrefix = '&'
                                if self.isPtrPtr(memb.decl_type):
                                    rawPrefix = ''

                                outSerStr += genStr(1, 'for (ssize_t i = 0; i < %s; i++)\n' % self.varSizeCountMap[currClass.name][memb.name])
                                outSerStr += genStr(2, '%s%s(%sraw->%s[i], pb->add_%s());' % (pbSerPrefix, pbType, rawPrefix, memb.name, memb.name.lower()))
                                outDesStr += genStr(1, 'for (ssize_t i = 0; i < pb->%s_size(); i++)\n' % (memb.name.lower(),))
                                outDesStr += genStr(2, '%s%s(node, %sraw->%s[i], pb->mutable_%s(i), idlSha);' % (pbDesPrefix, pbType, rawPrefix, memb.name, memb.name.lower()))
                            else:
                                outSerStr += genStr(1, 'for (ssize_t i = 0; i < %s; i++)\n' % self.varSizeCountMap[currClass.name][memb.name])
                                outSerStr += genStr(2, 'pb->add_%s()->set_value(raw->%s[i]);' % (memb.name.lower(), memb.name))
                                outDesStr += genStr(1, 'for (ssize_t i = 0; i < pb->%s_size(); i++)\n' % (memb.name.lower(),))
                                outDesStr += genStr(2, 'raw->%s[i] = pb->%s(i).value();' % (memb.name, memb.name.lower()))
                    elif declarations.is_array(memb.decl_type):
                        arrSize = self.getArrayDimSize(memb.decl_type, 0)
                        if arrSize:
                            arrSizeStr = str(arrSize)
                        else:
                            arrSizeStr = self.getArrayCount(currClass.name, memb.name)
                            if parentDepth == xcalarApiDepth:
                                if len(memb.parent.aliases) == 0:
                                    apiName = memb.parent.name
                                elif len(memb.parent.aliases) == 1:
                                    apiName = memb.parent.aliases[0].name
                                else:
                                    assert(False)
                                typeName = apiName
                                apiName = re.sub(r'Input.*$', r'', apiName)
                                outVarlenSizeStr += genStr(2, 'case %s:\n' % apiName)
                                if baseDeclStr == 'char':
                                    if self.is2DArray(memb.decl_type):
                                        outVarlenSizeStr += genStr(3, 'return(sizeof(((%s *)0x0)->%s[0]) * pb->%s().%s_size());\n' % (typeName, memb.name, parentName.lower(), memb.name.lower()))
                                    else:
                                        outVarlenSizeStr += genStr(3, 'return(sizeof(*((%s *)0x0)->%s) * pb->%s().%s().value().length());\n' % (typeName, memb.name, parentName.lower(), memb.name.lower()))
                                else:
                                    outVarlenSizeStr += genStr(3, 'return(sizeof(*((%s *)0x0)->%s) * pb->%s().%s_size());\n' % (typeName, memb.name, parentName.lower(), memb.name.lower()))

                        if declarations.is_fundamental(baseDecl) and not self.is2DArray(memb.decl_type):
                            if baseDeclStr == 'char':
                                iLevel = 1
                                postFix = ''
                                if isUnion:
                                    # This is the actual union, not the container of the union
                                    outSerStr += caseStr
                                    outDesStr += caseStr
                                    outUnionSizeStr += caseStr
                                    iLevel = 3
                                    outUnionSizeStr += genStr(iLevel, 'return(sizeof(((%s *)0x0)->%s));' % (rawType, memb.name))
                                    postFix = genStr(iLevel, 'break;')
                                    postFix = '\n' + postFix
                                    numUnionElms += 1
                                if arrSize:
                                    if declarations.is_pointer(declarations.array_item_type(memb.decl_type)):
                                        if declarations.is_fundamental(baseDecl):
                                            outSerStr += genStr(1, 'for (ssize_t i = 0; i < %s; i++)\n' % self.varSizeCountMap[currClass.name][memb.name])
                                            outSerStr += genStr(2, 'pb->add_%s()->set_value(std::string(raw->%s[i], strnlen(raw->%s[i], sizeof(raw->%s[i]))));' % (memb.name.lower(), memb.name, memb.name, memb.name)) + postFix
                                            outDesStr += genStr(1, 'for (ssize_t i = 0; i < pb->%s_size(); i++)\n' % (memb.name.lower(),))
                                            outDesStr += genStr(2, 'strlcpy(raw->%s[i], pb->%s(i).value().c_str(), sizeof(raw->%s[i]));' % (memb.name, memb.name.lower(), memb.name)) + postFix
                                        else:
                                            # This is an array of pointers to compound types.  Not currently supported.
                                            # Support involves dispatching type-specific routines and adding it to todoList.
                                            continue
                                    else:
                                        # XXX: Treat strings as bytes to work around bug 7730
                                        outSerStr += genStr(iLevel, 'pb->mutable_%s()->set_value(std::string(raw->%s, strnlen(raw->%s, sizeof(raw->%s))));' % (memb.name.lower(), memb.name, memb.name, memb.name)) + postFix
                                        outDesStr += genStr(iLevel, 'strlcpy(raw->%s, pb->%s().value().c_str(), sizeof(raw->%s));' % (memb.name, memb.name.lower(), memb.name)) + postFix
                                else:
                                    outSerStr += genStr(iLevel, 'pb->mutable_%s()->set_value(raw->%s);' % (memb.name.lower(), memb.name)) + postFix
                                    # XXX: Use of strlen here will go away once I add range checking/accounting
                                    outDesStr += genStr(iLevel, 'strlcpy(raw->%s, pb->%s().value().c_str(), strlen(pb->%s().value().c_str()) + 1);' % (memb.name, memb.name.lower(), memb.name.lower())) + postFix
                            else:
                                outSerStr += genStr(1, 'for (ssize_t i = 0; i < %s; i++)\n' % arrSizeStr)
                                outSerStr += genStr(2, 'pb->add_%s()->set_value(raw->%s[i]);' % (memb.name.lower(), memb.name))
                                outDesStr += genStr(1, 'for (ssize_t i = 0; i < pb->%s_size(); i++)\n' % (memb.name.lower(),))
                                outDesStr += genStr(2, 'raw->%s[i] = pb->%s(i).value();' % (memb.name, memb.name.lower()))
                        elif declarations.is_enum(baseDecl):
                            outSerStr += genStr(1, 'for (ssize_t i = 0; i < %s; i++)\n' % self.getArrayCount(currClass.name, memb.name))
                            outSerStr += genStr(2, 'pb->add_%s((%s)raw->%s[i]);' % (memb.name.lower(), self.pbNs+baseDeclStr, memb.name))
                            outDesStr += genStr(1, 'for (ssize_t i = 0; i < pb->%s_size(); i++)\n' % (memb.name.lower(),))
                            outDesStr += genStr(2, 'raw->%s[i] = (%s)pb->%s(i);' % (memb.name, baseDeclStr, memb.name.lower()))
                        else:
                            if declarations.is_pointer(memb.decl_type.base):
                                # Avoid serializing arrays of pointers such as
                                # XcalarApiMakeRetinaInput::tableArray
                                continue

                            if declarations.is_fundamental(baseDecl):
                                assert(self.is2DArray(memb.decl_type))
                                outSerStr += genStr(1, 'for (ssize_t i = 0; i < %s; i++)\n' % self.getArrayCount(currClass.name, memb.name))
                                outSerStr += genStr(2, 'pb->add_%s()->set_value(raw->%s[i]);' % (memb.name.lower(), memb.name))
                                outDesStr += genStr(1, 'for (ssize_t i = 0; i < pb->%s_size(); i++)\n' % (memb.name.lower(),))
                                # C requires all dimensions except the first be known at compile time.  So we do not use the arrSizeStr for this case
                                # since we're deserializing into the second dimension.
                                sz = self.getArrayDimSize(memb.decl_type, 1)
                                outDesStr += genStr(2, 'strlcpy(raw->%s[i], pb->%s(i).value().c_str(), %s);' % (memb.name, memb.name.lower(), sz))
                            else:
                                self.addTodo(baseDecl.declaration, memb.name, parentDepth)
                                outSerStr += genStr(1, 'for (ssize_t i = 0; i < %s; i++)\n' % self.getArrayCount(currClass.name, memb.name))
                                outSerStr += genStr(2, '%s%s(&raw->%s[i], pb->add_%s());' % (pbSerPrefix, baseDeclStr, memb.name, memb.name.lower()))
                                outDesStr += genStr(1, 'for (ssize_t i = 0; i < pb->%s_size(); i++)\n' % (memb.name.lower(),))
                                outDesStr += genStr(2, '%s%s(node, &raw->%s[i], pb->mutable_%s(i), idlSha);' % (pbDesPrefix, baseDeclStr, memb.name, memb.name.lower()))
                    elif declarations.is_enum(baseDecl):
                        # XXX Should generate wrappers for enums...
                        # XXX The casting is hacky, need to pull the IDL enums into the source
                        outSerStr += genStr(1, 'pb->set_%s((%s)raw->%s);' % (memb.name.lower(), self.pbNs+baseDeclStr, memb.name))
                        outDesStr += genStr(1, 'raw->%s = (%s)pb->%s();' % (memb.name, baseDeclStrOrig, memb.name.lower()))
                    elif type(baseDecl) == declarations.cpptypes.declarated_t:
                        assert(not declarations.is_fundamental(baseDecl))
                        # This is a compound type so no direct translation to protobuf
                        pbType = baseDeclStr

                        # If we haven't already, add the compount type to
                        # the list so we process it and generate a protobuf
                        # message for it
                        self.addTodo(baseDecl.declaration, memb.name, parentDepth)

                        if declarations.is_union(memb.decl_type):
                            try:
                                unionElm = self.unionElmSelectorMap[currClass.name]
                            except KeyError:
                                # No custom field selector for this union container so
                                # generate the standard name
                                unionElm = 'raw->' + memb.name + 'Elm'
                            # The current variable within the declaration is a
                            # union (ie this struct contains a union)
                            outSerStr += genStr(1, '%s%s(&raw->%s, pb->mutable_%s(), (int)%s);' % (pbSerPrefix, pbType, memb.name, memb.name.lower(), unionElm))
                            outDesStr += genStr(1, '%s%s(node, &raw->%s, pb->mutable_%s(), idlSha, (int)%s);' % (pbDesPrefix, pbType, memb.name, memb.name.lower(), unionElm))
                        else:
                            if isUnion:
                                # This is the actual union, not the container of the union
                                outUnionSizeStr += caseStr
                                outUnionSizeStr += genStr(3, 'return(sizeof(((%s *)0x0)->%s));' % (rawType, memb.name))

                                outSerStr += caseStr
                                outSerStr += genStr(3, '%s%s(&raw->%s, pb->mutable_%s());\n' % (pbSerPrefix, pbType, memb.name, memb.name.lower()))
                                outSerStr += genStr(3, 'break;')
                                outDesStr += caseStr
                                outDesStr += genStr(3, '%s%s(node, &raw->%s, pb->mutable_%s(), idlSha);\n' % (pbDesPrefix, pbType, memb.name, memb.name.lower()))
                                outDesStr += genStr(3, 'break;')
                                numUnionElms += 1
                            else:
                                outSerStr += genStr(1, '%s%s(&raw->%s, pb->mutable_%s());' % (pbSerPrefix, pbType, memb.name, memb.name.lower()))
                                outDesStr += genStr(1, '%s%s(node, &raw->%s, pb->mutable_%s(), idlSha);' % (pbDesPrefix, pbType, memb.name, memb.name.lower()))

                    else:
                        iLevel = 1
                        postFix = ''
                        if isUnion:
                            # This is the actual union, not the container of the union
                            outSerStr += caseStr
                            outDesStr += caseStr
                            outUnionSizeStr += caseStr
                            iLevel = 3
                            outUnionSizeStr += genStr(iLevel, 'return(sizeof(((%s *)0x0)->%s));' % (rawType, memb.name))
                            postFix = genStr(iLevel, 'break;')
                            postFix = '\n' + postFix
                            numUnionElms += 1
                        outSerStr += genStr(iLevel, 'pb->mutable_%s()->set_value(raw->%s);' % (memb.name.lower(), memb.name)) + postFix
                        outDesStr += genStr(iLevel, 'raw->%s = pb->%s().value();' % (memb.name, memb.name.lower())) + postFix

                    outSerStrList.append(outSerStr)
                    outDesStrList.append(outDesStr)
                    outUnionSizeList.append(outUnionSizeStr)
            except KeyError:
                # Cause compile to break
                outSerStr = 'XXX ERROR: cannot handle %s %s\n' % (str(memb.decl_type), memb.name, )
                self.printErr(outSerStr)
                outSerStrList.append(outSerStr)
                outDesStrList.append(outDesStr)


        outSerPrototype = '%s%s(%s *raw, %s *pb' % (pbSerPrefix, currClass.name, rawType, self.pbNs+currClass.name)
        # XXX: create a module-independant container
        if baseName == "DagDurable":
            arg0 = "Dag::SerializedDagNode *node"
        else:
            arg0 = "void **node"
        outDesPrototype = '%s%s(%s, %s *raw, %s *pb, const char * const idlSha' % (pbDesPrefix, currClass.name, arg0, rawType, self.pbNs+currClass.name)
        outVerPrototype = '%s%sMinorVers(%s, %s **raw, %s *pb, const char * const idlSha' % (pbDesPrefix, currClass.name, arg0, rawType, self.pbNs+currClass.name)
        outUnionSizePrototype = ''
        for argNum in range(0, numCountArgs):
            outSerPrototype += ', const ssize_t count' + str(argNum)
            outDesPrototype += ', const ssize_t count' + str(argNum)
            outVerPrototype += ', const ssize_t count' + str(argNum)

        if isUnion:
            outSerPrototype += ', const int unionType'
            outDesPrototype += ', const int unionType'
            outVerPrototype += ', const int unionType'
            outUnionSizePrototype = '%s%s(const int unionType)' % (pbUnionSizePrefix, currClass.name)

        outSerPrototype += ')'
        outDesPrototype += ')'
        outVerPrototype += ')'
        outSerStr = 'void ' + baseName + '::' + outSerPrototype + ' {\n'
        outDesStr = 'void ' + baseName + '::' + outDesPrototype + ' {\n'
        outSerPrototype = 'static void ' + outSerPrototype + ';'
        outDesPrototype = 'static void ' + outDesPrototype + ';'
        outVerPrototype = 'static void ' + outVerPrototype + ';'

        if isUnion:
            outSerStr += genStr(1, 'switch (unionType) {\n')
            outDesStr += genStr(1, 'switch (unionType) {\n')
            outUnionSizeStr = 'size_t ' + baseName + '::' + outUnionSizePrototype + ' {\n'
            outUnionSizePrototype = 'static size_t ' + outUnionSizePrototype + ';'
            outUnionSizeStr += genStr(1, 'switch (unionType) {\n')

        outSerStr += '\n'.join(outSerStrList)
        if isUnion:
            outDesStr += genStr(2, '%s%sMinorVersPre(node, &raw, pb, idlSha, unionType);\n' % (pbDesPrefix, currClass.name))
        else:
            outDesStr += genStr(1, '%s%sMinorVersPre(node, &raw, pb, idlSha);\n' % (pbDesPrefix, currClass.name))
        outDesStr += '\n'.join(outDesStrList)
        outSerStr += '\n'
        outDesStr += '\n'

        if isUnion:
            outUnionSizeStr += '\n'.join(outUnionSizeList)+'\n'

            outUnionSizeStr += genStr(2, 'default:\n')
            outUnionSizeStr += genStr(3, 'throw std::invalid_argument("Unsupported enum");\n')
            outUnionSizeStr += genStr(1, '}\n')
            outUnionSizeStr += '}\n'
            outSerStr += genStr(2, 'default:\n')
            outSerStr += genStr(3, 'throw std::invalid_argument("Unsupported enum");\n')
            outSerStr += genStr(1, '}\n')
            outDesStr += genStr(2, 'default:\n')
            outDesStr += genStr(3, 'throw std::invalid_argument("Unsupported enum");\n')
            outDesStr += genStr(1, '}\n')
            outDesStr += genStr(1, '%s%sMinorVers(node, &raw, pb, idlSha, unionType);\n' % (pbDesPrefix, currClass.name))
        else:
            outDesStr += genStr(1, '%s%sMinorVers(node, &raw, pb, idlSha);\n' % (pbDesPrefix, currClass.name))

        outSerStr += '}\n'
        outDesStr += '}\n'

        return (outSerStr, outSerPrototype, outDesStr, outDesPrototype, outVerPrototype, outUnionSizePrototype, outUnionSizeStr, outVarlenSizeStr)

    def makePublic(self, name, prototype, isDeserialize):
        funcOrigName = re.sub(r'^.* (\w+)\(.*', r'\1', prototype)
        funcProto = re.sub(r'^.* (\w+)(\(.*);', r'static MustCheck Status \1Pub\2', prototype)
        outStr = genStr(1, funcProto + ' {\n')

        nargs = prototype.count(',')
        if isDeserialize:
            if nargs == 3:
                argStr = '(node, raw, pb, idlSha);\n'
            elif nargs == 4:
                argStr = '(node, raw, pb, idlSha, unionType);\n'
            else:
                assert(False)
        else:
            if nargs == 1:
                argStr = '(raw, pb);\n'
            elif nargs == 2:
                argStr = '(raw, pb, unionType);\n'
            else:
                assert(False)

        outStr += genStr(2, 'try {\n')
        outStr += genStr(3, funcOrigName + argStr)
        outStr += genStr(3, 'return StatusOk;\n')

        if isDeserialize:
            errStatStr = 'StatusProtobufDecodeError'
        else:
            errStatStr = 'StatusProtobufEncodeError'

        outStr += genStr(2, '} catch(std::bad_alloc) {\n')
        outStr += genStr(3, 'return(StatusNoMem);\n')
        outStr += genStr(2, '} catch(std::invalid_argument) {\n')
        outStr += genStr(3, 'return(StatusInval);\n')
        outStr += genStr(2, '} catch(std::exception& e) {\n')
        outStr += genStr(3, 'return(%s);\n' % (errStatStr,))
        outStr += genStr(2, '}\n')

        outStr += genStr(1, '}\n')

        return outStr

    def genClassOps(self, indent, baseName):
        out = '%s() {}\n' % (baseName,)
        out += '~%s() {}\n' % (baseName,)
        out += '%s(const %s&) = delete;\n' % (baseName, baseName,)
        out += '%s(const %s&&) = delete;\n' % (baseName, baseName,)
        out += '%s& operator=(const %s&) = delete;\n' % (baseName, baseName,)
        out += '%s& operator=(const %s&&) = delete;\n' % (baseName, baseName,)
        return blkInd(indent, out)+'\n'

    def getDeclByName(self, motherStruct):
        criteria = declarations.declaration_matcher(name=motherStruct, decl_type=declarations.class_declaration.class_t)
        declObj = declarations.matcher.find(criteria, self.global_ns)
        # If full namespace path isn't specified we might get multiple nodes from different namespaceses
        assert(len(declObj) == 1)
        return declObj[0]

    def wrapVarlenSizes(self, proto, sizes):
        return '''%s {
    switch ((XcalarApis) api) {
%s
        default:
            return 0;
    }
}
''' % (proto, sizes)

    # Breadth-first traversal of structs
    def parseStructsToC(self, motherStruct):
        serdesChanged = False
        self.processedList = []

        motherDecl = self.getDeclByName(motherStruct)
        self.todoList = [TodoItem(motherDecl, '', 0)]

        outStrs = '\n'
        cPrototypes = ''
        outDesStrs = '\n'
        outDesPrototypes = ''
        outSerDict = {}
        outSerPrototypesDict = {}
        outDesDict = {}
        outDesPrototypesDict = {}
        outVerPrototypesDict = {}
        outUnionSizeDict = {}
        publicUnionSizeDict = {}
        publicSerDict = {}
        publicDesDict = {}

        baseName = os.path.basename(args.cout)
        baseProtoName = os.path.basename(args.proto)
        baseProtoName = re.sub(r'V.', r'', baseProtoName)
        outVarlenSizeStrs = ''

        while self.todoList:
            todoItem = self.todoList.pop(0)
            currClass = todoItem.decl
            if currClass in self.processedList:
                continue

            # Enums should never be on the SerDes list
            assert(not declarations.is_enum(currClass))

            (outStr, cPrototype, outDesStr, outDesPrototype, outVerPrototype, outUnionSizePrototype, outUnionSizeStr, outVarlenSizeStr) =\
                    self.parseStructToC(currClass, todoItem.depth, todoItem.name, baseName)
            outVarlenSizeStrs += outVarlenSizeStr
            outSerDict[currClass.name] = outStr
            outSerPrototypesDict[currClass.name] = cPrototype
            outDesDict[currClass.name] = outDesStr
            outDesPrototypesDict[currClass.name] = outDesPrototype
            outVerPrototypesDict[currClass.name] = outVerPrototype
            if outUnionSizePrototype:
                assert(outUnionSizeStr)
                outUnionSizeDict[currClass.name] = outUnionSizeStr
                publicUnionSizeDict[currClass.name] = genStr(1, outUnionSizePrototype)
            if currClass.name in self.public:
                publicSerDict[currClass.name] = self.makePublic(currClass.name, cPrototype, False)
                publicDesDict[currClass.name] = self.makePublic(currClass.name, outDesPrototype, True)

        cPrototypes = sortDictToStr(outSerPrototypesDict)+'\n'
        outStrs = sortDictToStr(outSerDict)
        outDesPrototypes = sortDictToStr(outDesPrototypesDict)+'\n'
        outDesStrs = sortDictToStr(outDesDict)
        publicSerStrs = sortDictToStr(publicSerDict)+'\n'
        publicDesStrs = sortDictToStr(publicDesDict)
        outVerStrs = sortDictToStr(outVerPrototypesDict)
        outUnionSizeStrs = sortDictToStr(outUnionSizeDict)
        publicUnionSizeStrs = sortDictToStr(publicUnionSizeDict)

        global copyrightEtc, autogenMsg, cInc

        includeBase = os.path.join(args.xcalar, "src/include")
        relativeInclude = os.path.relpath(args.fin, includeBase)
        cInc += '#include "{}"\n'.format(relativeInclude)
        cInc += '#include "subsys/%s.pb.h"\n' % (baseProtoName,)

        cHdr = copyrightEtc + autogenMsg + '\n'

        out = cHdr
        out += genStr(0, '#ifndef _%s_H_\n' % (baseName.upper(),))
        out += genStr(0, '#define _%s_H_\n' % (baseName.upper(),))
        out += cInc

        methods = genStr(0,  '// ---------------- Serialization Routines ----------------\n')
        methods += cPrototypes + '\n'
        methods += genStr(0, '// --------------- Deserialization Routines ---------------\n')
        methods += outDesPrototypes + '\n'
        methods += genStr(0, '// --------------- Minor Versioning Routines --------------\n')
        methods += outVerStrs + '\n'
        methods += genStr(0, '// ------------- Minor Versioning PreRoutines -------------\n')
        methods += re.sub(r'MinorVers', r'MinorVersPre', outVerStrs, flags=re.M)
        methods = blkInd(1, methods)

        publicVarlenSizesProto = 'size_t %spbGetVarlenSizes(const int api, xcalar::internal::durable::dag::XcalarApiInput *pb)'
        classOut = genStr(0, 'class ' + baseName + '{\n')
        classOut += genStr(0, 'public:\n')
        classOut += publicSerStrs
        classOut += publicDesStrs + '\n'
        if baseName == 'DagDurable':
            classOut += '    static ' + publicVarlenSizesProto % '' + ';\n\n'
        classOut += genStr(1, '// ------------------ Union Size Routines -----------------\n')
        classOut += publicUnionSizeStrs + '\n'
        classOut += genStr(0, 'private:\n')
        classOut += "    static constexpr const char *ModuleName = \"lib%s\";\n" % baseName;
        classOut += self.genClassOps(1, baseName)
        if baseName == 'DagDurable':
            classOut += genStr(1, 'static void durDagRealloc(Dag::SerializedDagNode *node, void **raw, size_t newSize);\n\n')
        classOut += methods
        classOut += genStr(0, '};')

        newHeader = out + '\n' + classOut + '\n#endif'
        headerFname = args.cout + '.h'
        try:
            with open(headerFname, 'r') as fh:
                currHeader = fh.read()
        except IOError:
            # No existing file
            currHeader = ''

        if newHeader != currHeader:
            print('Writing SerDes header: ' + headerFname)
            with open(headerFname, 'w') as fh:
                fh.write(newHeader)
            serdesChanged = True

        out = genStr(0, '#include "%s.h"\n' % (baseName,))
        out += 'using namespace xcalar::internal;\n\n'
        out = cHdr + cInc + out + '\n'
        methods = genStr(0,  '// ---------------- Serialization Routines ----------------\n')
        methods += outStrs + '\n'
        methods += genStr(0, '// --------------- Deserialization Routines ---------------\n')
        methods += outDesStrs + '\n'
        methods += genStr(0, '// ------------------ Union Size Routines -----------------\n')
        methods += outUnionSizeStrs + '\n'
        if baseName == 'DagDurable':
            methods += genStr(0, '// ------------------ API Variable Size Routines -----------------\n')
            methods += self.wrapVarlenSizes(publicVarlenSizesProto % 'DagDurable::', outVarlenSizeStrs)

        newCpp = out + methods
        cppFname = args.cout + '.cpp'
        try:
            with open(cppFname, 'r') as fh:
                currCpp = fh.read()
        except IOError:
            # No existing file
            currCpp = ''
        if newCpp != currCpp:
            print('Writing SerDes code: ' + cppFname)
            with open(cppFname, 'w') as fh:
                fh.write(newCpp)
            serdesChanged = True

        currVerPrototypes = []
        out = ''

        mvFname = args.cout + 'MinorVers' + '.cpp'
        if os.path.isfile(mvFname):
            mvRewrite = False
            minorVersOut = ''
            with open(mvFname, 'r') as fh:
                line = fh.readline()
                while line:
                    match = re.match(r'void \w+::pbDes(\w+)MinorVers\(.*\) {', line)
                    if match:
                        # Remove any minor version hooks for compound fields removed from C-structs
                        if match.group(1) not in [elm.name for elm in self.processedList]:
                            mvRewrite = True
                            while line[0] != '}':
                                line = fh.readline()
                            line = fh.readline()
                            assert(line[0] == '\n')
                            line = fh.readline()
                            continue
                        else:
                            # Collect all existing minor vers hooks
                            currVerPrototypes.append(match.group(0))
                    minorVersOut += line
                    line = fh.readline()
            if mvRewrite:
                with open(mvFname, 'w') as fh:
                    fh.write(minorVersOut)
        else:
            # If the minor vers hooks don't exist, add the header
            out = genStr(0, '#include "%s.h"\n' % (baseName,))
            out += genStr(0, '#include "DurableVersions.h"\n')
            out += genStr(0, '#include "durable/Durable.h"\n')
            out = copyrightEtc + minorVersMsg + cInc + out + '\n'

        for prototype in sortDict(outVerPrototypesDict):
            replStr = r'void %s::\1\2 {\n\n}\n\n' % (baseName,)
            tmpStr = re.sub(r'^.* (\w+)(\(.*);', replStr, prototype)
            replPreStr = r'void %s::\1Pre\2 {\n\n}\n\n' % (baseName,)
            tmpPreStr = re.sub(r'^.* (\w+)(\(.*);', replPreStr, prototype)
            if tmpStr.split('\n')[0] not in currVerPrototypes:
                # Only append new hooks to avoid overwriting existing custom hooks
                out += tmpPreStr
                out += tmpStr

        with open(mvFname, 'a') as fh:
            fh.write(out)

        return serdesChanged

    def parseVarsize(self, currClass, parentDepth, parentList):
        if type(currClass) != declarations.class_declaration.class_t:
            return ''

        if currClass.name in self.blist:
            return ''

        self.processedList.append(currClass)
        membersList = currClass.get_members()

        while membersList:
            memb = membersList.pop(0)
            if type(memb) == declarations.variable.variable_t:
                if str(memb.decl_type) in self.blist:
                    continue

                if self.isAnon(memb):
                    membersList += memb.decl_type.declaration.get_members()
                    continue

                baseDecl = declarations.base_type(memb.decl_type)

                if type(baseDecl) == declarations.cpptypes.declarated_t and not declarations.is_fundamental(baseDecl):
                    # if not declarations.is_pointer(memb.decl_type):
                    self.addTodo(baseDecl.declaration, memb.name, parentDepth, parentList)

                if declarations.is_array(memb.decl_type):
                    arrSize = self.getArrayDimSize(memb.decl_type, 0)
                    if not arrSize:
                        # if parentDepth >= 3:
                            # if not declarations.is_pointer(declarations.array_item_type(memb.decl_type)):

                        # TODO: automate nested varlens by adding this to a dictionary keyed on the 3rd level type
                        # to be added during C code generation of the variable allocation size function.
                        # print("%s: %s, %s, %d" % (parentList, memb.name, memb.decl_type, parentDepth))
                        print("%s: %s, %s, %d" % (parentList, memb.name, memb.decl_type, parentDepth))

    def parseVarsizes(self, motherStruct):
        self.processedList = []

        motherDecl = self.getDeclByName(motherStruct)
        # print declarations.full_name(motherDecl)
        self.todoList = [TodoItem(motherDecl, '', 0, [motherStruct])]

        while self.todoList:
            todoItem = self.todoList.pop(0)
            currClass = todoItem.decl
            if currClass in self.processedList:
                continue

            self.parseVarsize(currClass, todoItem.depth, todoItem.parentList)

    def runParse(self):
        if args.varlen:
            self.parseVarsizes(args.durable)
            sys.exit(0)
        idlChanged = self.parseStructs(args.durable)
        serdesChanged = self.parseStructsToC(args.durable)
        if idlChanged or serdesChanged:
            # Return 1 indicating changed IDL or SerDes
            print("IDL and/or SerDes change detected, please rebuild to pick up changes")
            return 1
        else:
            return 0

myGenProto = GenProto()
retval = myGenProto.runParse()

sys.exit(retval)

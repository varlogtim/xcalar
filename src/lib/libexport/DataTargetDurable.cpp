// Copyright 2017 Xcalar, Inc. All rights reserved.
//
// No use, or distribution, of this source code is permitted in any form or
// means without a valid, written license agreement with Xcalar, Inc.
// Please refer to the included "COPYING" file for terms and conditions
// regarding the use and redistribution of this software.

// Updating durable data structures must be done with care.  Please carefully
// read http://wiki.int.xcalar.com/mediawiki/index.php/Durables for instructions.

// This file AUTOGENERATED
// DO NOT EDIT THIS FILE BY HAND

// ===> http://wiki.int.xcalar.com/mediawiki/index.php/Durables for details


#include <exception>
#include "StrlFunc.h"
#include "sys/XLog.h"

#include "export/DataTarget.h"
#include "subsys/DurableDataTarget.pb.h"
#include "DataTargetDurable.h"
using namespace xcalar::internal;


// ---------------- Serialization Routines ----------------
void DataTargetDurable::pbSerExAddTargetSFInput(ExAddTargetSFInput *raw, xcalar::internal::durable::datatarget::ExAddTargetSFInput *pb) {
    pb->mutable_url()->set_value(std::string(raw->url, strnlen(raw->url, sizeof(raw->url))));
}

void DataTargetDurable::pbSerExAddTargetSpecificInput(ExAddTargetSpecificInput *raw, xcalar::internal::durable::datatarget::ExAddTargetSpecificInput *pb, const int unionType) {
    switch (unionType) {
        case ExTargetSFType:
            pbSerExAddTargetSFInput(&raw->sfInput, pb->mutable_sfinput());
            break;
        case ExTargetUDFType:
            pbSerExAddTargetUDFInput(&raw->udfInput, pb->mutable_udfinput());
            break;
        default:
            throw std::invalid_argument("Unsupported enum");
    }
}

void DataTargetDurable::pbSerExAddTargetUDFInput(ExAddTargetUDFInput *raw, xcalar::internal::durable::datatarget::ExAddTargetUDFInput *pb) {
    pb->mutable_url()->set_value(std::string(raw->url, strnlen(raw->url, sizeof(raw->url))));
    pb->mutable_appname()->set_value(std::string(raw->appName, strnlen(raw->appName, sizeof(raw->appName))));
}

void DataTargetDurable::pbSerExExportTarget(ExExportTarget *raw, xcalar::internal::durable::datatarget::ExExportTarget *pb) {
    pbSerExExportTargetHdr(&raw->hdr, pb->mutable_hdr());
    pbSerExAddTargetSpecificInput(&raw->specificInput, pb->mutable_specificinput(), (int)raw->hdr.type);
}

void DataTargetDurable::pbSerExExportTargetHdr(ExExportTargetHdr *raw, xcalar::internal::durable::datatarget::ExExportTargetHdr *pb) {
    pb->set_type((xcalar::internal::durable::datatarget::ExTargetType)raw->type);
    pb->mutable_name()->set_value(std::string(raw->name, strnlen(raw->name, sizeof(raw->name))));
}

void DataTargetDurable::pbSerTargetListPersistedData(DataTargetManager::TargetListPersistedData *raw, xcalar::internal::durable::datatarget::TargetListPersistedData *pb) {
    pb->mutable_totallength()->set_value(raw->totalLength);
    pb->mutable_version()->set_value(raw->version);
    pbSertimespec(&raw->persistTime, pb->mutable_persisttime());
    pb->mutable_targetscount()->set_value(raw->targetsCount);
    for (ssize_t i = 0; i < raw->targetsCount; i++)
        pbSerTargetPersistHeader(&raw->targets[i], pb->add_targets());
}

void DataTargetDurable::pbSerTargetPersistHeader(DataTargetManager::TargetPersistHeader *raw, xcalar::internal::durable::datatarget::TargetPersistHeader *pb) {
    pb->mutable_targetsize()->set_value(raw->targetSize);
    pbSerExExportTarget(&raw->target, pb->mutable_target());
}

void DataTargetDurable::pbSertimespec(timespec *raw, xcalar::internal::durable::datatarget::timespec *pb) {
    pb->mutable_tv_sec()->set_value(raw->tv_sec);
    pb->mutable_tv_nsec()->set_value(raw->tv_nsec);
}

// --------------- Deserialization Routines ---------------
void DataTargetDurable::pbDesExAddTargetSFInput(void **node, ExAddTargetSFInput *raw, xcalar::internal::durable::datatarget::ExAddTargetSFInput *pb, const char * const idlSha) {
    pbDesExAddTargetSFInputMinorVersPre(node, &raw, pb, idlSha);
    strlcpy(raw->url, pb->url().value().c_str(), sizeof(raw->url));
    pbDesExAddTargetSFInputMinorVers(node, &raw, pb, idlSha);
}

void DataTargetDurable::pbDesExAddTargetSpecificInput(void **node, ExAddTargetSpecificInput *raw, xcalar::internal::durable::datatarget::ExAddTargetSpecificInput *pb, const char * const idlSha, const int unionType) {
    switch (unionType) {
        pbDesExAddTargetSpecificInputMinorVersPre(node, &raw, pb, idlSha, unionType);
        case ExTargetSFType:
            pbDesExAddTargetSFInput(node, &raw->sfInput, pb->mutable_sfinput(), idlSha);
            break;
        case ExTargetUDFType:
            pbDesExAddTargetUDFInput(node, &raw->udfInput, pb->mutable_udfinput(), idlSha);
            break;
        default:
            throw std::invalid_argument("Unsupported enum");
    }
    pbDesExAddTargetSpecificInputMinorVers(node, &raw, pb, idlSha, unionType);
}

void DataTargetDurable::pbDesExAddTargetUDFInput(void **node, ExAddTargetUDFInput *raw, xcalar::internal::durable::datatarget::ExAddTargetUDFInput *pb, const char * const idlSha) {
    pbDesExAddTargetUDFInputMinorVersPre(node, &raw, pb, idlSha);
    strlcpy(raw->url, pb->url().value().c_str(), sizeof(raw->url));
    strlcpy(raw->appName, pb->appname().value().c_str(), sizeof(raw->appName));
    pbDesExAddTargetUDFInputMinorVers(node, &raw, pb, idlSha);
}

void DataTargetDurable::pbDesExExportTarget(void **node, ExExportTarget *raw, xcalar::internal::durable::datatarget::ExExportTarget *pb, const char * const idlSha) {
    pbDesExExportTargetMinorVersPre(node, &raw, pb, idlSha);
    pbDesExExportTargetHdr(node, &raw->hdr, pb->mutable_hdr(), idlSha);
    pbDesExAddTargetSpecificInput(node, &raw->specificInput, pb->mutable_specificinput(), idlSha, (int)raw->hdr.type);
    pbDesExExportTargetMinorVers(node, &raw, pb, idlSha);
}

void DataTargetDurable::pbDesExExportTargetHdr(void **node, ExExportTargetHdr *raw, xcalar::internal::durable::datatarget::ExExportTargetHdr *pb, const char * const idlSha) {
    pbDesExExportTargetHdrMinorVersPre(node, &raw, pb, idlSha);
    raw->type = (ExTargetType)pb->type();
    strlcpy(raw->name, pb->name().value().c_str(), sizeof(raw->name));
    pbDesExExportTargetHdrMinorVers(node, &raw, pb, idlSha);
}

void DataTargetDurable::pbDesTargetListPersistedData(void **node, DataTargetManager::TargetListPersistedData *raw, xcalar::internal::durable::datatarget::TargetListPersistedData *pb, const char * const idlSha) {
    pbDesTargetListPersistedDataMinorVersPre(node, &raw, pb, idlSha);
    raw->totalLength = pb->totallength().value();
    raw->version = pb->version().value();
    pbDestimespec(node, &raw->persistTime, pb->mutable_persisttime(), idlSha);
    raw->targetsCount = pb->targetscount().value();
    for (ssize_t i = 0; i < pb->targets_size(); i++)
        pbDesTargetPersistHeader(node, &raw->targets[i], pb->mutable_targets(i), idlSha);
    pbDesTargetListPersistedDataMinorVers(node, &raw, pb, idlSha);
}

void DataTargetDurable::pbDesTargetPersistHeader(void **node, DataTargetManager::TargetPersistHeader *raw, xcalar::internal::durable::datatarget::TargetPersistHeader *pb, const char * const idlSha) {
    pbDesTargetPersistHeaderMinorVersPre(node, &raw, pb, idlSha);
    raw->targetSize = pb->targetsize().value();
    pbDesExExportTarget(node, &raw->target, pb->mutable_target(), idlSha);
    pbDesTargetPersistHeaderMinorVers(node, &raw, pb, idlSha);
}

void DataTargetDurable::pbDestimespec(void **node, timespec *raw, xcalar::internal::durable::datatarget::timespec *pb, const char * const idlSha) {
    pbDestimespecMinorVersPre(node, &raw, pb, idlSha);
    raw->tv_sec = pb->tv_sec().value();
    raw->tv_nsec = pb->tv_nsec().value();
    pbDestimespecMinorVers(node, &raw, pb, idlSha);
}

// ------------------ Union Size Routines -----------------
size_t DataTargetDurable::pbUnionSizeExAddTargetSpecificInput(const int unionType) {
    switch (unionType) {
        case ExTargetSFType:
            return(sizeof(((ExAddTargetSpecificInput *)0x0)->sfInput));
        case ExTargetUDFType:
            return(sizeof(((ExAddTargetSpecificInput *)0x0)->udfInput));
        default:
            throw std::invalid_argument("Unsupported enum");
    }
}


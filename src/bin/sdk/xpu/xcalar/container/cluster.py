import itertools
import bisect
import logging
import pickle

import xcalar.container.context as _ctx
import xcalar.container.parent as _xce
import xcalar.container.xpuComm as _xpu_comm

_BIG_PRIME = 103113233

logger = logging.getLogger("xcalar")


class XpuCluster:
    """This class provides information about the running XPU cluster.

    XPU clusters run in many instances on each Xcalar node in a Xcalar cluster.
    This creates a 2 level hierarchy where each XPU has an associated identity
    within its local node, as well as an identity within the set of all XPUs
    across all nodes.

    """

    def __init__(self):
        # All of the below could be done lazily if we so desired
        xce_client = _xce.Client()

        self.my_xpu_id = _ctx.get_xpu_id()
        """xpu id in the xpu cluster associated with this XPU"""
        self.my_node_id = _ctx.get_node_id(self.my_xpu_id)
        """Xcalar node id associated with this XPU"""
        self.xpus_per_node = _ctx.get_num_xpus_per_node()
        """number of XPUs associated with each Xcalar node"""
        self.total_size = _ctx.get_xpu_cluster_size()
        """total number of XPUs across the Xcalar cluster"""
        self.num_nodes = _ctx.get_node_count()
        """number of Xcalar nodes in the cluster"""
        self.unique_run_id = int(xce_client.get_group_id(), 16)
        """unique number associated with this XPU cluster"""
        self.master_xpu_id = (
            _BIG_PRIME * self.unique_run_id) % self.total_size
        """selected master XPU for this cluster"""

        start_ids = [0]
        start_ids[1:] = list(itertools.accumulate(self.xpus_per_node[:-1]))
        self._xpu_start_ids = start_ids

    def is_master(self):
        """Return whether this XPU is the master of this XPU cluster.

        Each time an XPU cluster is created, an XPU is designated the master.
        This master XPU does not have any special capabilities beyond being
        recognized cluster-wide as the master. When a usecase requires having
        some work be done once and only once, it is easiest to simply have the
        master do the work. It is also common to have the master XPU be an
        aggregator for results generated by the rest of the cluster.

        :return_type: :class:`bool`
        """
        return self.my_xpu_id == self.master_xpu_id

    def is_local_master(self):
        """Return whether this XPU is local master of this Xcalar node.

        On each Xcalar node of a cluster, a single XPU is designated as the
        local master. This is very similar to :meth:`is_master`, but applies
        only to the local Xcalar node, rather than the distributed XPU cluster.

        :return_type: :class:`bool`
        """
        return self.my_xpu_id == self.local_master_for_node(self.my_node_id)

    def node_for_xpu(self, xpu_id):
        """Get the node associated for some given XPU.

        :param xpu_id: Given XPU ID
        :type xpu_id: int
        :return_type: :class:`int`"""
        if xpu_id > self.total_size:
            raise ValueError(
                "xpu_id {} not valid; cluster is only {} xpus".format(
                    xpu_id, self.total_size))

        # Binary search the start ids
        # bisect([0,8,3], 0) == 1, because it would insert to the right of 0,
        # so we need to subtract 1 to get the actual node
        return bisect.bisect(self._xpu_start_ids, xpu_id) - 1

    def local_master_for_xpu(self, xpu_id):
        """Get the local master for some given XPU.

        On each Xcalar node of a cluster, a single XPU is designated as the
        local master. This is very similar to :meth:`is_master`, but applies
        only to the local Xcalar node, rather than the distributed XPU cluster.
        This method returns the local master associated with some XPU.

        :param xpu_id: Given XPU ID
        :type xpu_id: int
        :return_type: :class:`int`"""
        if xpu_id > self.total_size:
            raise ValueError(
                "xpu_id {} not valid; cluster is only {} xpus".format(
                    xpu_id, self.total_size))
        node_id = self.node_for_xpu(xpu_id)
        return self.local_master_for_node(node_id)

    def local_master_for_node(self, node_id):
        """Get the local master for some given node.

        On each Xcalar node of a cluster, a single XPU is designated as the
        local master. This is very similar to :meth:`is_master`, but applies
        only to the local Xcalar node, rather than the distributed XPU cluster.
        This method returns the local master associated with a given node.

        :param xpu_id: Given node id
        :type xpu_id: int
        :return_type: :class:`int`"""
        if node_id >= self.num_nodes:
            raise ValueError(
                "node_id {} not valid; cluster is only {} nodes".format(
                    node_id, self.num_nodes))
        # XXX right now this is just the first XPU on the node. Maybe this is
        # okay, since all the XPUs on a given node share the same set of
        # resources (CPU/mem/network).
        return self._xpu_start_ids[node_id]

    def broadcast_msg(self, message):
        """Sends a message to every other XPU in the cluster.

        Serializes the given `message` using :mod:`pickle` and sends
        it to the other XPU in the cluster. This function WILL BLOCK until the
        message has been received at all XPUs. All XPUs must invoke
        :meth:`recv_msg` in order to receive the message. If the destination
        XPU does not receive, this method will block forever, resulting in
        deadlock!

        :param message: Message to send to each other XPU in the cluster
        :type message: object
        """
        msgs = []
        for xpu_id in range(self.total_size):
            if xpu_id != self.my_xpu_id:
                msgs.append((xpu_id, pickle.dumps(message)))
        if msgs:
            _xpu_comm.send_fanout(msgs)

    def send_msg_batch(self, messages):
        """Sends a message to each other XPU in the cluster.

        Serializes the given `messages` using :mod:`pickle` and sends it to
        each XPU in the cluster other than the one sending it. Element 0 in the
        `messages` array will be sent to XPU 0, element 1 will be sent to XPU
        1, etc. The element of `messages` which corresponds to THIS XPU will be
        ignored. This function WILL BLOCK until the message has been received.
        The destination XPU must invoke :meth:`recv_msg` in order to receive
        the message. If the destination XPU does not receive, this method will
        block forever, resulting in deadlock!

        :param messages: Messages to send to the other XPU in the cluster
        :type messages: list
        """
        # XXX fix this up
        if len(messages) != self.total_size:
            raise ValueError(
                "length of messages {} does not equal the number of XPUs in the cluster"
                .format(len(messages), self.total_size))
        packed_messages = [(xpu_id, pickle.dumps(msg))
                           for xpu_id, msg in enumerate(messages)
                           if xpu_id != self.my_xpu_id]
        if packed_messages:
            _xpu_comm.send_fanout(packed_messages)

    def send_msg(self, dest_xpu_id, message):
        """Sends a message to another XPU in the cluster.

        Serializes the given `message` using :mod:`pickle` and sends
        it to the other XPU in the cluster. This function WILL BLOCK until the
        message has been received. The destination XPU must invoke
        :meth:`recv_msg` in order to receive the message. If the destination
        XPU does not receive, this method will block forever, resulting in
        deadlock!

        :param dest_xpu_id: XPU ID of the recipient of this message
        :type dest_xpu_id: int
        :param message: Message to send to the other XPU in the cluster
        :type message: object
        """
        serialized_message = pickle.dumps(message)
        _xpu_comm.send_msg(dest_xpu_id, serialized_message)

    def recv_msg(self):
        """Receives a message from another XPU in the cluster.

        Deserializes the received message using :mod:`pickle`. This method
        WILL BLOCK until a message has been received. If no message is sent,
        this method will block forever, resulting in deadlock!"""
        raw_message = _xpu_comm.recv_msg()
        message = pickle.loads(raw_message)
        return message

    def barrier(self):
        """Blocks until all XPUs in the cluster have called barrier

        Waits until all XPUs in this XPU cluster invoke barrier. If any of
        these XPUs DO NOT invoke barrier, then this call will block forever,
        resulting in deadlock!"""
        _xpu_comm.barrier_wait()


def get_running_cluster():
    """Get the currently running XPU cluster

    :return_type: :class:`XpuCluster`"""
    return XpuCluster()

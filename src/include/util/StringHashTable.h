// Copyright 2016-2020 Xcalar, Inc. All rights reserved.
//
// No use, or distribution, of this source code is permitted in any form or
// means without a valid, written license agreement with Xcalar, Inc.
// Please refer to the included "COPYING" file for terms and conditions
// regarding the use and redistribution of this software.
//

#ifndef STRINGHASHTABLE_H
#define STRINGHASHTABLE_H

#include <string.h>
#include <stddef.h>
#include "util/StringHashTableHook.h"
#include "hash/Hash.h"    // hashStringFast
#include "util/System.h"  // memZero

// Used to help developers notice when they're deferencing a hook that's
// been removed (and not added back). Address not valid in user mode.
#define STRING_HASHTABLE_POISON (StringHashTableHook *) 0xf33df00ddeafd00d

//
// This hashtable associates a string key to a generic value. It makes the
// following assumptions:
//
// - Collisions are rare.
// - Most uses of this table will result in new object code being generated.
// - Consumer is responsible for any synchronization.
//
// To give as much control to the consumer as possible, this provides:
// - Duplicate keys aren't allowed. Remove and replace.
// - Collisions are dealt with via chaining keys that map to the same slot in
//   a linked list.
// - An iterator is provided to list all elements in the hashtable.
//
// DO NOT EDIT THIS FILE unless your addition is necessary for *all* consumers.
// Get sign-off from the team on any additions. If your use-case needs
// additional functionality, create a similar, but modified, hash table.
//

template <typename V,                          // Value type.
          StringHashTableHook V::*HookMember,  // Member of V that defines hook.
          const char *(V::*KeyFn)() const,  // Function on V that defines key.
          size_t SlotCount,                 // Number of slots.
          uint64_t (*HashFn)(const char *) = hashStringFast>  // Hash function.
class StringHashTable final
{
  public:
    StringHashTable()
    {
        // Initialize chain base pointers to NULL.
        memZero(slots, sizeof(slots));
    }

    // Associate value with key. Returns StatusExist if duplicate key.
    Status insert(V *value)
    {
        const char *key = (value->*KeyFn)();
        size_t slot = HashFn(key) % SlotCount;
        StringHashTableHook *hook = &(value->*HookMember);

        // In-order insertion.
        StringHashTableHook *prev = NULL;
        for (StringHashTableHook *current = slots[slot];
             unlikely(current != NULL);
             prev = current, current = current->next) {
            // Extract key from current item's hook.
            V *currentValue = hookToValue(current);
            const char *currentKey = (currentValue->*KeyFn)();

            int cmp = strcmp(key, currentKey);
            if (unlikely(cmp == 0)) {
                // No duplicates.
                return StatusExist;
            } else if (cmp < 0) {
                // Insert before current place in list.
                if (likely(prev == NULL)) {
                    hook->next = slots[slot];
                    slots[slot] = hook;
                } else {
                    assert(prev->next == current);
                    hook->next = current;
                    prev->next = hook;
                }
                size_++;

                return StatusOk;
            }
        }

        // Didn't insert yet. Insert at end.
        if (likely(prev == NULL)) {
            assert(slots[slot] == NULL);
            hook->next = slots[slot];
            slots[slot] = hook;
        } else {
            assert(slots[slot] != NULL);
            hook->next = NULL;
            prev->next = hook;
        }

        size_++;

        return StatusOk;
    }

    // Return associated value or NULL if none exists.
    V *find(const char *key) const
    {
        size_t slot = HashFn(key) % SlotCount;

        for (StringHashTableHook *current = slots[slot]; current != NULL;
             current = current->next) {
            // Extract key from current item's hook.
            V *currentValue = hookToValue(current);
            const char *currentKey = (currentValue->*KeyFn)();

            if (likely(strcmp(key, currentKey) == 0)) {
                return currentValue;
            }
        }

        // Not found.
        return NULL;
    }

    // Remove from hash table and return associated value or NULL if none
    // exists.
    V *remove(const char *key)
    {
        size_t slot = HashFn(key) % SlotCount;

        StringHashTableHook *prev = NULL;
        for (StringHashTableHook *current = slots[slot]; current != NULL;
             prev = current, current = current->next) {
            // Extract key from current item's hook.
            V *currentValue = hookToValue(current);
            const char *currentKey = (currentValue->*KeyFn)();

            if (likely(strcmp(key, currentKey) == 0)) {
                // Remove from list.
                if (likely(prev == NULL)) {
                    slots[slot] = current->next;
                } else {
                    prev->next = current->next;
                }
                size_--;

                assert(current->next != STRING_HASHTABLE_POISON);
                debug(current->next = STRING_HASHTABLE_POISON);
                return currentValue;
            }
        }

        return NULL;
    }

    // Removes all elements in hashtable. Calls removeFn once on each value if
    // non-NULL. If using deleteFn, ensure you handle duplicate values.
    void removeAll(void (V::*deleteFn)())
    {
        for (size_t slot = 0; slot < SlotCount; slot++) {
            StringHashTableHook *next;
            for (StringHashTableHook *current = slots[slot]; current != NULL;
                 current = next) {
                next = current->next;

                V *currentValue = hookToValue(current);
                assert(current->next != STRING_HASHTABLE_POISON);
                debug(current->next = STRING_HASHTABLE_POISON);
                if (deleteFn != NULL) {
                    (currentValue->*deleteFn)();
                }
            }
        }
        size_ = 0;
        memZero(slots, sizeof(slots));  // Set chain heads to NULL.
    }

    class iterator final
    {
      public:
        iterator(StringHashTable &ht) : hashTable(ht), slot(0), hook(NULL)
        {
            hook = hashTable.slots[slot];  // Base of slot.
            findNext();
        }

        V *get()
        {
            if (unlikely(hook == NULL)) {
                return NULL;
            }
            return hashTable.hookToValue(hook);
        }

        void next()
        {
            if (hook != NULL) {
                hook = hook->next;
                findNext();
            }
        }

      private:
        void findNext()
        {
            while (slot < SlotCount) {
                if (hook != NULL) {
                    // Found one!
                    break;
                }
                slot++;
                if (likely(slot < SlotCount)) {
                    hook = hashTable.slots[slot];  // Base of slot.
                }
            }
        }

        StringHashTable &hashTable;
        size_t slot;                // Slot current belongs to.
        StringHashTableHook *hook;  // Current hook.

        iterator &operator=(const iterator &) = delete;
    };

    iterator begin() { return iterator(*this); }

    unsigned getSize() const { return size_; }

    bool empty() const { return size_ == 0; }

  private:
    // Get a V* from a StringHashTableHook.
    V *hookToValue(StringHashTableHook *hook) const
    {
        size_t offset = (uintptr_t)(&(((V *) 0)->*HookMember));

        return (V *) ((uintptr_t) hook - offset);
    }

    unsigned size_ = 0;
    StringHashTableHook *slots[SlotCount];

    StringHashTable(const StringHashTable &) = delete;
    StringHashTable &operator=(const StringHashTable &) = delete;
};

#endif  // STRINGHASHTABLE_H

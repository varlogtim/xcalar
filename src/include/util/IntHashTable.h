// Copyright 2016 Xcalar, Inc. All rights reserved.
//
// No use, or distribution, of this source code is permitted in any form or
// means without a valid, written license agreement with Xcalar, Inc.
// Please refer to the included "COPYING" file for terms and conditions
// regarding the use and redistribution of this software.
//

#ifndef INTHASHTABLE_H
#define INTHASHTABLE_H

#include <assert.h>
#include "util/IntHashTableHook.h"
#include "util/System.h"  // memZero

#ifdef DEBUG
// Used to help developers notice when they're deferencing a hook that's
// been removed (and not added back). Address not valid in user mode.
#define INT_HASHTABLE_POISON (IntHashTableHook *) 0xf33df00ddeafd00d
#endif  // DEBUG

//
// Key type, K, must be an integral type. This hashtable associates an integral
// key to a generic value. It makes the following assumptions:
//
// - Collisions are rare.
// - Most uses of this table will result in new object code being generated.
// - Consumer is responsible for any synchronization.
//
// To give as much control to the consumer as possible, this provides:
// - Duplicate keys aren't allowed. Remove and replace.
// - Collisions are dealt with via chaining keys that map to the same slot in
//   a linked list.
//
// DO NOT EDIT THIS FILE unless your addition is necessary for *all* consumers.
// Get sign-off from the team on any additions. If your use-case needs
// additional functionality, create a similar, but modified, hash table.
//

template <typename K,                       // Integral key type.
          typename V,                       // Value type.
          IntHashTableHook V::*HookMember,  // Member of V that defines hook.
          K (V::*KeyFn)() const,            // Function on V that defines key.
          size_t SlotCount,                 // Number of slots.
          uint64_t (*HashFn)(const K)>      // Hash function.
class IntHashTable final
{
  public:
    IntHashTable()
    {
        // Initialize chain base pointers to NULL.
        memZero(slots, sizeof(slots));
    }

    // Associate value with key defined by (value->*KeyFn)(). Returns
    // StatusExist if duplicate key.
    Status insert(V *value)
    {
        const K key = (value->*KeyFn)();
        size_t slot = HashFn(key) % SlotCount;
        IntHashTableHook *hook = &(value->*HookMember);

        // In-order insertion.
        IntHashTableHook *prev = NULL;
        for (IntHashTableHook *current = slots[slot]; unlikely(current != NULL);
             prev = current, current = current->next) {
            // Extract key from current item's hook.
            V *currentValue = hookToValue(current);
            const K currentKey = (currentValue->*KeyFn)();

            if (unlikely(key == currentKey)) {
                // No duplicates.
                return StatusExist;

            } else if (key < currentKey) {
                // Insert before current place in list.
                if (likely(prev == NULL)) {
                    hook->next = slots[slot];
                    slots[slot] = hook;
                } else {
                    assert(prev->next == current);
                    hook->next = current;
                    prev->next = hook;
                }

                size_++;
                return StatusOk;
            }
        }

        // Didn't insert yet. Insert at end.
        if (likely(prev == NULL)) {
            assert(slots[slot] == NULL);
            hook->next = slots[slot];
            slots[slot] = hook;
        } else {
            assert(slots[slot] != NULL);
            hook->next = NULL;
            prev->next = hook;
        }

        size_++;
        return StatusOk;
    }

    // Return associated value or NULL if none exists.
    V *find(K key) const
    {
        size_t slot = HashFn(key) % SlotCount;

        for (IntHashTableHook *current = slots[slot]; current != NULL;
             current = current->next) {
            // Extract key from current item's hook.
            V *currentValue = hookToValue(current);
            const K currentKey = (currentValue->*KeyFn)();

            if (likely(key == currentKey)) {
                return currentValue;
            }
        }

        // Not found.
        return NULL;
    }

    // Remove from hash table and return associated value or NULL if none
    // exists.
    V *remove(K key)
    {
        size_t slot = HashFn(key) % SlotCount;

        IntHashTableHook *prev = NULL;
        for (IntHashTableHook *current = slots[slot]; current != NULL;
             prev = current, current = current->next) {
            // Extract key from current item's hook.
            V *currentValue = hookToValue(current);
            const K currentKey = (currentValue->*KeyFn)();

            if (likely(key == currentKey)) {
                // Remove from list.
                if (likely(prev == NULL)) {
                    slots[slot] = current->next;
                } else {
                    prev->next = current->next;
                }

                debug(current->next = INT_HASHTABLE_POISON);
                size_--;
                return currentValue;
            }
        }

        return NULL;
    }

    // Removes all elements in hashtable. Calls removeFn once on each value if
    // non-NULL. If using deleteFn, ensure you handle duplicate values.
    void removeAll(void (V::*deleteFn)())
    {
        for (size_t slot = 0; slot < SlotCount; slot++) {
            IntHashTableHook *next;
            for (IntHashTableHook *current = slots[slot]; current != NULL;
                 current = next) {
                next = current->next;

                V *currentValue = hookToValue(current);
                debug(current->next = INT_HASHTABLE_POISON);
                if (deleteFn != NULL) {
                    (currentValue->*deleteFn)();
                }
            }
        }
        size_ = 0;
        memZero(slots, sizeof(slots));  // Set chain heads to NULL.
    }

    class iterator final
    {
      public:
        iterator(IntHashTable &hashTable)
            : hashTable_(hashTable), slot_(0), hook_(NULL)
        {
            hook_ = hashTable_.slots[slot_];
            findNext();
        }

        V *get()
        {
            if (unlikely(hook_ == NULL)) {
                return NULL;
            }
            return hashTable_.hookToValue(hook_);
        }

        void next()
        {
            if (hook_ != NULL) {
                hook_ = hook_->next;
                findNext();
            }
        }

      private:
        void findNext()
        {
            while (slot_ < SlotCount) {
                if (hook_ != NULL) {
                    // Found one!
                    break;
                }
                slot_++;
                if (likely(slot_ < SlotCount)) {
                    hook_ = hashTable_.slots[slot_];  // Base of slot.
                }
            }
        }

        IntHashTable &hashTable_;
        size_t slot_;             // Slot current belongs to.
        IntHashTableHook *hook_;  // Current hook.

        iterator &operator=(const iterator &) = delete;
    };

    iterator begin() { return iterator(*this); }

    unsigned getSize() { return size_; }

  private:
    // Get a V* from a IntHashTableHook.
    V *hookToValue(IntHashTableHook *hook) const
    {
        size_t offset = (uintptr_t)(&(((V *) 0)->*HookMember));
        return (V *) ((uintptr_t) hook - offset);
    }

    IntHashTable(const IntHashTable &) = delete;
    IntHashTable &operator=(const IntHashTable &) = delete;

    unsigned size_ = 0;
    IntHashTableHook *slots[SlotCount];
};

#endif  // INTHASHTABLE_H

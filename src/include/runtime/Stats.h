// Copyright 2020 Xcalar, Inc. All rights reserved.
//
// No use, or distribution, of this source code is permitted in any form or
// means without a valid, written license agreement with Xcalar, Inc.
// Please refer to the included "COPYING" file for terms and conditions
// regarding the use and redistribution of this software.
//

#ifndef RUNTIME_STATS_H
#define RUNTIME_STATS_H

#include "primitives/Status.h"

#include <chrono>
#include <memory>
#include <string>

class FiberSchedThread;
class StatsCollector;
class RuntimeHistogramsResponse;

// The main class for the users' types that performs tracking and reporting.
// Create an instance as a member of your task/operation and call the public API
// to log events.
class Stats final : public std::enable_shared_from_this<Stats>
{
  public:
    explicit Stats(const char *name) : name_(name)
    {
        counters_.start = std::chrono::steady_clock::now();
        counters_.finish = std::chrono::steady_clock::time_point::max();
    }

    // Called once during initialization to register the object with the infra.
    void start();

    // Called when the owning Schedulable object is being finalized to log the
    // finish time.
    void finish();

    // Additional counters for each stat instance.
    void incSuspensions() { ++counters_.suspensions; }
    void incSuspendedTime(int64_t us) { counters_.suspendedTimeus += us; }
    void incLockingTime(int64_t us) { counters_.infraLockingTimeus += us; }

    struct Counters {
        std::chrono::steady_clock::time_point start, finish;
        int64_t suspensions = 0;
        int64_t suspendedTimeus = 0;
        int64_t infraLockingTimeus = 0;
    };

    const Counters &counters() const { return counters_; }

    // TODO(Oleg): this should become std::string_view when we move to C+17.
    std::string name() const { return name_; }

  private:
    // User-provided name displayed in the status pages. This typically points
    // to the .rodata section so that no memory management is needed.
    //
    // TODO(Oleg): this should become std::string_view when we move to C+17.
    const char *name_;

    // Unique ID generated by the collector for this piece of stats.
    int64_t id_ = -1;

    // Additional counters relevant to the libruntime implementation.
    Counters counters_;
};

// Stats collection infra - it is a very thin entry point for the collection and
// aggregation code. The initial cut also had the "running" and "finished" op
// sets, but that implementation proved too expensive. The current version just
// fetches the stats digest from fiber threads and can be further extended to
// deal with "running" ops.
class StatsCollector final
{
  public:
    // This is a singleton that we explicitly construct (from a single-threaded
    // path) and use (from multiple threads).
    static void construct();
    static void shutdown();

    static StatsCollector &instance()
    {
        assert(instance_ != nullptr);
        return *instance_;
    }

    // Registers a new piece of stats, marks it as "started" and returns the
    // unique ID.
    int64_t start(std::shared_ptr<Stats> stats);

    // API for the status pages - we export data as protos and the "SystemPerf"
    // app exposes it over HTTP.
    Status exportFinished(RuntimeHistogramsResponse *resp) const;

  private:
    StatsCollector();

    static StatsCollector *instance_;

    // Let's hide the class' state so that changes in the stats never leak to
    // the world and the compilation remains minimal and fast.
    struct State;
    std::unique_ptr<State> state_;
};

#endif  // RUNTIME_STATS_H
